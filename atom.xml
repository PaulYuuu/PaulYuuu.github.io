<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnanasYu的博客</title>
  
  <subtitle>寡言少语，生人勿近</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ananasyu.top/"/>
  <updated>2018-05-21T10:43:13.431Z</updated>
  <id>https://www.ananasyu.top/</id>
  
  <author>
    <name>Ananas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 Dockerfile 构建 Rally 和 Tempest 容器镜像</title>
    <link href="https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html"/>
    <id>https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html</id>
    <published>2018-05-18T11:00:00.000Z</published>
    <updated>2018-05-21T10:43:13.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　<code>Rally</code> 和 <code>Tempest</code> 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。</p><p>　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：</p><ol><li><font color="#008844"> 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； </font></li><li><font color="#008844"> 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； </font></li><li><font color="#008844"> 易扩展可复用：将构建需求分成多步 <font color="#FF0000"> Step </font> 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 <font color="#FF0000"> Libcontainer </font> 引擎也令跨平台复用变得易如反掌； </font></li><li><font color="#008844"> 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。</font></li></ol><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　Dockerfile 作为镜像的描述文件，以简单的命令定义每一 Step 中镜像该做的事情，并将每一次步骤后的镜像 commit 为一个新镜像继续执行后续步骤。每增加一步 Step ，镜像会增加一个 layer 层，所以合理地设计及编写 Dockerfile 文件，避免镜像层次过于臃肿也是门需要思考的艺术。借此通过构建 Rally 以及 Tempest 的容器镜像，也顺便理解 Dockerfile 的文件结构及编写规范。</p><h3 id="Rally"><a href="#Rally" class="headerlink" title="Rally"></a>Rally</h3><blockquote><p>　　Rally 是一个基准测试工具，Rally 实现了自动化并统一了多个节点的 OpenStack 部署、云的验证、基准测试以及分析，以这种通用的方式去验证“ OpenStack 是如何大规模运作的？”这样的疑问，比如在数以千计的服务器下的高负载中是否正常工作。因此，可以将它作为 OpenStack CI/CD 系统的基本工具来使用，借以不断地改进 SLA（ Service-Level Agreement ）、性能和稳定性。</p></blockquote><div align="center" style="align:center"><br><font size="6">Rally 架构 </font><br><img src="https://rally.readthedocs.io/en/stable/_images/Rally-Actions.png" alt="Rally 架构" title="Rally架构"><br></div><p>　　Rally 自己提供了 Docker 镜像存储在 <a href="https://hub.docker.com/r/xrally/xrally-openstack/" title="Rally官方Docker镜像" target="_blank" rel="noopener">Docker Hub</a> 上，也可以从 Github 上下载<a href="https://github.com/openstack/rally" title="Rally源码" target="_blank" rel="noopener"> Rally 源码</a>自己修改构建。接下来结合官方的 Dockerfile 文件，自定义修改属于我们自己的 Rally 镜像。</p><h6 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定一个基础镜像进行构建。命令参数 <code>FROM &lt;image&gt;:&lt;tag&gt;</code> ，这里使用 ubuntu:16.04 作为 Rally 的基础镜像，它将作为镜像第一层完成后续步骤构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　指定作者信息。命令参数 <code>MAINTAINER &lt;name&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Rally 所需依赖包及创建相应目录。Dockerfile 使用 <code>RUN &lt;command&gt;</code> 调用系统 shell 运行相关命令，多个命令不建议分别写多个 <code>RUN</code> 指令，因为这会使镜像层次变得复杂，而是建议使用 <code>&amp;&amp;</code> 和 <code>\</code> 连接多条命令并换行书写，优化构建的逻辑结构和代码的可读性。通过下述 5 个步骤完成前期准备，其中 source 是我用来存放下载源码的目录。</p><ul><li>更新软件列表</li><li>安装依赖软件</li><li>时区改为 CST</li><li>反注释开启命令参数补齐</li><li>创建 Rally 源码下载目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils iputils-ping vim wget git-core tzdata \</span><br><span class="line">    python python-pip python-dev &amp;&amp; \</span><br><span class="line">    pip install --upgrade pip &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/rally/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载 Rally 的安装脚本并进行必要修改后进行安装，同时替换掉需要调用墙外的 js 框架文件变为我们可访问的目标地址。</p><ul><li>下载 12.0.0 的 Rally 安装文件到 <code>/home/rally/</code></li><li>替换安装版本为 12.0.0</li><li>修改 Rally 的 <code>database</code> 保存在 <code>/home/rally/data/</code></li><li>下载的源码保存在 <code>/home/rally/source/</code></li><li>安装时拷贝 Rally 命令补全文件及开启运行容器时输出相关 Info</li><li>安装 Rally</li><li>替换 googleapis 上的 <code>angular.min.js</code> 为 cloudflare 网站上面的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RUN wget -P /home/rally/ https://raw.githubusercontent.com/openstack/rally/0.12.0/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_GIT_BRANCH=.*/RALLY_GIT_BRANCH="0.12.0"/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_DATABASE_DIR=.*/RALLY_DATABASE_DIR=\/home\/rally\/data/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/SOURCEDIR="\$ORIG_WD".*/SOURCEDIR="\$ORIG_WD"\/home\/rally\/source/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'cp $SOURCEDIR/etc/motd /etc/motd'</span> &gt;&gt; /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ ! -z "$TERM" -a -r /etc/motd ] &amp;&amp; cat /etc/motd'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'source /usr/local/etc/bash_completion.d/rally.bash_completion'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    bash /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/report.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/trends.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/verification/report.html</span><br></pre></td></tr></table></figure><h6 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　拷贝 <code>build</code> 过程中指定的上下文目录文件到镜像内部。命令参数 <code>COPY &lt;src&gt;... &lt;dest&gt;</code> ，可以通过同目录下的 <code>.dockerignore</code> 忽略部分不需要传输的文件。这里我是将 Rally 自动测试的执行脚本拷贝到镜像内部，方便后续测试。</p><p>　　还有另外一个命令 <code>ADD</code> 可以理解为增强版的 <code>COPY</code> ，它不仅能将本地目录的文件拷贝到镜像中，同时还能降远程 url 的文件或目录拷贝至镜像里面，如果源文件是一个压缩包，在拷贝过程中还会自动解压。它的命令参数与 <code>COPY</code> 无二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY . /home/rally/</span><br></pre></td></tr></table></figure><h6 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　安装完毕后清理 apt 以及 pip 安装过程中的缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">    rm -rf /root/.cache/</span><br></pre></td></tr></table></figure><h6 id="Step-7"><a href="#Step-7" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　建立存放数据库的 <code>/home/rally/data/</code> 目录并重新创建 Rally 的数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /home/rally/data &amp;&amp; \</span><br><span class="line">    rally db recreate</span><br></pre></td></tr></table></figure><h6 id="Step-8"><a href="#Step-8" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　更改镜像工作目录，使得启动镜像后在 <code>/home/rally/</code> 目录执行命令等。命令参数 <code>WORKDIR &lt;dir&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /home/rally</span><br></pre></td></tr></table></figure><h6 id="Step-9"><a href="#Step-9" class="headerlink" title="Step 9"></a>Step 9</h6><p>　　为了令测试数据持久化，将镜像数据存储文件夹挂载到宿主机，命令参数 <code>VLOUME [&quot;&lt;dir&gt;&quot;]</code> 。启动容器的时候会在 <code>/var/lib/docker/volumes/</code> 下创建一个随机命名的文件夹并将其挂载关联，也可在启动时通过 <code>-v</code> 挂载到指定目录，便于数据的查看及持久化保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/home/rally"</span>]</span><br></pre></td></tr></table></figure><h6 id="Step-10"><a href="#Step-10" class="headerlink" title="Step 10"></a>Step 10</h6><p>　　官方是以 <code>ENTRYPOINT [&quot;rally&quot;]</code> 作为容器启动时的默认命令。我们启动容器时指定的命令都将作为参数传给 <code>rally</code> 调用，不会被重写覆盖，这也导致我们无法直接进入容器内部去执行其他操作，解决办法是在使用 <code>docker run</code> 的时候用 <code>--rm --entrypoint /bin/bash</code> 临时替换。测试过程中我喜欢进去容器内部操作，因此摒弃 <code>ENTRYPOINT</code> 而用 <code>CMD</code> 命令，它允许我们启动时用别的命令覆盖，进行其他操作。两者的命令参数为 <code>ENTRYPOINT/CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 。一个Dockerfile文件仅允许一个<code>ENTRYPOINT</code> 和 <code>CMD</code> 存在，多次存在的话只有最后一次会生效。当两者同时存在的情况下，可以使用 <code>CMD</code> 给 <code>ENTRYPOINT</code> 传参，比如 <code>ENTRYPOINT [&quot;rally&quot;]</code> <code>CMD [&quot;--version&quot;]</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此一个 Rally 的 Dockerfile 文件编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Rally 容器镜像。构建完毕后可通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t rally_container:0.12.0 .</span><br></pre></td></tr></table></figure><h6 id="附录：Rally-Documentation"><a href="#附录：Rally-Documentation" class="headerlink" title="附录：Rally Documentation "></a><font color="#FF0000">附录：Rally Documentation </font></h6><div class="row">    <embed src="https://media.readthedocs.org/pdf/rally/stable/rally.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Tempest"><a href="#Tempest" class="headerlink" title="Tempest"></a>Tempest</h3><blockquote><p>　　Tempest 是 Openstack 的集成测试框架，对于验证 OpenStack 部署，包含了基本组件的 API 测试、场景测试和单元测试。Tempest 对 Openstack 终端发起一系列 API 请求，并且对终端的响应进行验证。它可以验证代码的正确性，使得 OpenStack 相关测试效率得到大幅度提升，已经成为 OpenStack 项目中不可或缺的组成部分。</p></blockquote><div align="center" style="align:center"><br><font size="6">Tempest 代码架构 <br></font><br><img src="https://www.ibm.com/developerworks/cn/cloud/library/1403_liuyu_openstacktempest/image005.jpg" alt="Tempest 代码架构" title="Tempest 代码架构"><br><br></div><p>　　Tempest 没有官方的 Docker 镜像提供给我们参考和使用，我们可以按照自己安装过程中的步骤配置 Dockerfile 文件。此处仅记录我安装习惯的配置。</p><h6 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定 ubuntu:16.04 作为基础镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　备注作者信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Tempest 依赖软件包、修改时区、反注释命令补全功能，创建源码下载目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils vim git wget curl gcc tzdata \</span><br><span class="line">    python-dev python-libxml2 python-setuptools \</span><br><span class="line">    libxml2-dev libxslt-dev lib32z1-dev libssl-dev libxslt1-dev libsasl2-dev libsqlite3-dev libldap2-dev libffi-dev &amp;&amp; \</span><br><span class="line">    easy_install pip &amp;&amp; \</span><br><span class="line">    pip install --upgrade setuptools &amp;&amp; \</span><br><span class="line">    pip install xunit2testrail junitxml virtualenv python-openstackclient &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/tempest/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4-1"><a href="#Step-4-1" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载版本为 18.0.0 的 Tempest 源码，<code>pip</code> 安装所需依赖组件及调试所需的 <code>ipdb</code> ，最后安装 Tempest。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    git <span class="built_in">clone</span> -b 18.0.0 https://git.openstack.org/openstack/tempest ./ &amp;&amp; \</span><br><span class="line">    pip install -r ./requirements.txt &amp;&amp; \</span><br><span class="line">    pip install -r ./<span class="built_in">test</span>-requirements.txt &amp;&amp; \</span><br><span class="line">    pip install nose tox ipdb &amp;&amp; \</span><br><span class="line">    pip install .</span><br></pre></td></tr></table></figure><h6 id="Step-5-1"><a href="#Step-5-1" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　生成配置文件样本并拷贝一份以便后续配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    tox -egenconfig &amp;&amp; \</span><br><span class="line">    cp etc/accounts.yaml.sample etc/accounts.yaml &amp;&amp; \</span><br><span class="line">    cp etc/tempest.conf.sample etc/tempest.conf</span><br></pre></td></tr></table></figure><h6 id="Step-6-1"><a href="#Step-6-1" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　在 <code>/home/tempest/workdir</code> 文件夹中初始化 Tempest。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN tempest init /home/tempest/workdir</span><br></pre></td></tr></table></figure></p><h6 id="Step-7-1"><a href="#Step-7-1" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　指定 Tempest 工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /root/tempest/workdir</span><br></pre></td></tr></table></figure><h6 id="Step-8-1"><a href="#Step-8-1" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　指定容器启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此 Tempest 的 Dockerfile 文件也已编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Tempest 镜像。构建完毕后通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t tempest_container:18.0.0 .</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>　　通过 Dockerfile 构建 Rally 以及 Tempest 镜像，不仅能让我们快速的搭建测试环境，也利于持续集成及持续交付过程中节省时间，统一及标准化环境。而且与 OpenStack 隔离开来，更是减少了测试过程中的互相干扰。并且 <code>Docker volume</code> 的存在也确保了测试输出结果能同步保存至宿主机并持久化。</p><p>　　最后将 Rally 以及 Tempest 的容器镜像上传至 <code>Docker Hub</code> 或者保存至本地 <code>registry</code> ，方便后续使用。</p><ul><li><a href="https://hub.docker.com/r/ananasyuu/docker_rally/" target="_blank" rel="noopener">Rally 镜像的 Docker Hub 链接</a></li><li><a href="https://hub.docker.com/r/ananasyuu/docker_tempest/" target="_blank" rel="noopener">Tempest 镜像的 Docker Hub 链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　&lt;code&gt;Rally&lt;/code&gt; 和 &lt;code&gt;Tempest&lt;/code&gt; 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。&lt;/p&gt;
&lt;p&gt;　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 易扩展可复用：将构建需求分成多步 &lt;font color=&quot;#FF0000&quot;&gt; Step &lt;/font&gt; 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 &lt;font color=&quot;#FF0000&quot;&gt; Libcontainer &lt;/font&gt; 引擎也令跨平台复用变得易如反掌； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。&lt;/font&gt;

&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.ananasyu.top/categories/Docker/"/>
    
    
      <category term="Dockerfile" scheme="https://www.ananasyu.top/tags/Dockerfile/"/>
    
      <category term="Rally" scheme="https://www.ananasyu.top/tags/Rally/"/>
    
      <category term="Tempest" scheme="https://www.ananasyu.top/tags/Tempest/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Hexo !</title>
    <link href="https://www.ananasyu.top/posts/Hello-Hexo.html"/>
    <id>https://www.ananasyu.top/posts/Hello-Hexo.html</id>
    <published>2018-05-10T09:50:30.000Z</published>
    <updated>2018-05-21T10:39:50.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo1.jpg" alt=""><br></div><a id="more"></a><p>　</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　回想起高二高三那时折腾塞班系统的固件，为 <font color="#66CDAA">Nokia N79</font> 美化及优化原生系统；从高三暑假才拥有属于自己的电脑的小白到大学当网管头头带领十几个人穿梭在男男女女的学生宿舍之中，解决 Ta 们使用校园网遇到的各种问题（然而也没有找到另一半Ｔ▽Ｔ）；再到现如今藏匿在<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%B9%BF%E5%B7%9E%E7%A0%94%E7%A9%B6%E9%99%A2/92623" title="中国电信广州研究院" target="_blank" rel="noopener">中国电信广州研究院</a>从事着虚拟化及云计算测试相关。发现自己的涉猎面越来越广，无论技术还是兴趣~~~</p><p>　　没事哼哼小曲儿，凭着自己头脑里的想法去尝试改进工作中的流程，能将工作融入到生活中是我希望达到的状态。作为一个测试人员需要学习的知识还是很多，产品熟悉度及工具的创新及运用也不是件容易事。希望接下来的博客能较多的涉猎以下内容，鞭策自己向着更深更好的方向前进。</p><ul><li><div><img style="margin:0px 6px 7px 0px" src="https://wiki.openstack.org/favicon.ico" width="27" height="27"> <a href="https://www.openstack.org/" target="_blank" rel="noopener"><font size="5">OpenStack</font></a></div></li><li><div><img style="margin:0px 1px 12px -5px" src="https://www.docker.com/favicon.ico" width="36" height="36"> <a href="https://www.docker.com/" target="_blank" rel="noopener"><font size="5">Docker</font></a></div></li><li><div><img style="margin:0px 10px 10px 0px" src="https://jenkins.io/sites/default/files/jenkins_favicon.ico" width="27" height="27"> <a href="https://jenkins.io/" target="_blank" rel="noopener"><font size="5">Jenkins</font></a></div></li><li><div><img style="margin:0px 5px 6px 0px" src="https://www.python.org/static/favicon.ico" width="27" height="27"> <a href="https://www.python.org/" target="_blank" rel="noopener"><font size="5">Python</font></a><br><br></div></li></ul><p>　　趁着现在热情正盛，工作中的 idea 和技术实现还没有忘记的时候及时记录下来，弥补日常工作总结中的不足。就怕前期高产，等到脑中的想法被挖空得差不多了之后就写不出东西了，走走看看呗。接下来的日子里，立个目标——每周一篇以上的文章。等到以后过上了佛系养生亦或者工作忙碌的无暇更新的时候，再回头看看自己曾经写下的经历、不足以及成长！！！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>　　折腾了几天下来，博客的雏形就暂时定这样子吧。使用 <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 搭建博客还是挺简单的。当看到这个博客展现在眼前的时候，心情确实有点激动，也特别感谢 <a href="http://litten.me" title="Litten的博客" target="_blank" rel="noopener">Litten</a> 制作的主题 <a href="https://github.com/litten/hexo-theme-yilia" title="Yilia主题" target="_blank" rel="noopener">Yilia</a>，非常喜欢这种简洁的双栏主题，交互方便又美观大方。说实在的，第一次尝试用 <a href="http://wowubuntu.com/markdown/index.html" title="Markdown语法中文完整版" target="_blank" rel="noopener">Markdown</a> 语法写文章，而且好久没执笔写过东西了，以后再慢慢改进排版吧！</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo2.jpg" alt=""><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="essay" scheme="https://www.ananasyu.top/tags/essay/"/>
    
  </entry>
  
</feed>
