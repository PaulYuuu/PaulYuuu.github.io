<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnanasYu的博客</title>
  
  <subtitle>寡言少语，生人勿近</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ananasyu.top/"/>
  <updated>2018-07-14T15:49:16.437Z</updated>
  <id>https://www.ananasyu.top/</id>
  
  <author>
    <name>Ananas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我回来了！</title>
    <link href="https://www.ananasyu.top/posts/Comeback.html"/>
    <id>https://www.ananasyu.top/posts/Comeback.html</id>
    <published>2018-07-14T07:00:00.000Z</published>
    <updated>2018-07-14T15:49:16.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　荒废了一个多月的博客，现在总算是有点时间再拾起来了。这一个月忙碌着，也颓废着，发生的事情太多，让我自己都感到意外。离开了广州，来到了帝都，算是开启了人生的新篇章。今后可能也不能每周更新博客，而是无定时更新。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><h3 id="奇妙的体验"><a href="#奇妙的体验" class="headerlink" title="奇妙的体验"></a><strong>奇妙的体验</strong></h3><p>　　在广州电信研究院，前前后后也呆了一年的时间，收获很多，离开确实也有一分不舍，只是说不想局限在一个较为传统的环境中。世界那么大，还是需要出去看看的，在金三银四的那两个月里，也质疑过自己，也迷失过方向。本想着去深圳逛一逛，却发现和自己想要的，其实还是有点偏差。没想到的是在 app 上收藏的一个岗位，反而被 HR 小美女联系上了，而后的事情，直至今日我都还没缓过来，除了激动，也只剩下激动了。谢谢 Aileen，谢谢 Vivian，谢谢 Miya 以及面试我的各位同事，自己何德何能，得以拥抱这样一个开源大家庭，唯有不断学习，才能保证自己不被落下。</p><p>　　公司今年25岁，恰好我今年也是25岁，这也是一种缘分。只是相比起来，公司是多么的伟大，而我是多么的平凡。作为行业的标杆，几乎每天都会接触到，而现在能融入到当中去，这应该就是给我度过本命年后的褒奖吧！</p><h3 id="北京之行"><a href="#北京之行" class="headerlink" title="北京之行"></a><strong>北京之行</strong></h3><p>　　第一次离开广东，前往帝都朝圣，真心是一次值得记录的旅途。等到稳定之后，肯定要好好的逛一逛，见识一下老北京的风土人情，去看看各个景点，到冬天的时候再体验一场南方没有的大雪，好多好多的事情想要完成，填写进人生的道路中。</p><p>　　三个小时多一点的飞机，看着地上的建筑慢慢的缩小，缩小，而后消失在云端之下。在高空之上透过窗户看外面的云朵，真的是好漂亮，是一种无法用相机表达出来的惊艳的美。在飞机上体验了一次飞机餐，南航的服务还是蛮不错的。并且透过前面的终端看了东野圭吾小说《解忧杂货店》改编而成的同名电影，可能和小说比起来是有些不足，但是至少也比国内翻拍的那一部好看，帮助我打发了飞机上闲暇的时间。</p><p>　　下了飞机之后，就打的去了朋友那里，不然作为一个北漂，刚到达目的地那种环境带来的陌生感肯定会把我笼罩。也许在广州呆久了，有些习惯还是没很好的适应。这边的 BRT 和公交，采用的是上下打卡的方式，有点类似地铁。同样是分段收费，却又不同于深圳的人工售票。游走在北京的街道上，喜欢那种纯正的普通话，我也想练成那种带儿化音的腔调。在朋友的陪同下去了一下<a href="https://baike.baidu.com/item/%E5%8D%97%E9%94%A3%E9%BC%93%E5%B7%B7/6200499?fr=aladdin" title="南锣鼓巷百科" target="_blank" rel="noopener">南锣鼓巷</a>，街上好不热闹，即使是上班日都随处可见来自五湖四海的游客以及旅游团。看着带有北京味道的建筑还有小胡同，吃着一根老冰棍，真的是蛮惬意的。晚上经过<a href="https://baike.baidu.com/item/%E5%90%8E%E6%B5%B7/6037?fr=aladdin" title="后海百科" target="_blank" rel="noopener">后海</a>，酒吧一条街，可能是太早，也没有看到驻台歌手唱歌，最终就是离开而没有进去感受一下那种不掺杂过多伴奏的纯粹的歌声。</p><p>　　最折腾的事应该就是找房子了。预算一步步提高，而且对路况不熟悉，只能保险选择10号线周边的来租。本着能不找中介就不找中介的原则（不然押一付三再加上中介费吃不消啊），每天就看那么一两间房子，要么是环境不满意要么就是太贵，本来打算租宋家庄附近了，结果人家又反悔……最终在星期六中午打算找自如的时候来了个最后的挣扎，就那么巧合的看到了在首经贸旁边的小区房子。看房押金隔天入住直接搞定，真的算是幸运了。房间里2米*2，4米的大床，真的是横着睡、竖着睡、斜着睡都完全没问题啊！！！</p><p>　　入住之后慢慢的购置一些用品，现在也算是一个不错的私人空间了。房间不算大，但是收纳的地方挺多的，而且是类似榻榻米的大床，床下面也可以放置很多的物件，所以房间能收拾的很整洁，这一点我就满足了。</p><h3 id="入职一周"><a href="#入职一周" class="headerlink" title="入职一周"></a><strong>入职一周</strong></h3><p>　　首先要说的是，公司真的 <strong>nice</strong>，9点有早餐，11点有水果，然后下午3点又有点心可以吃，我感觉我的增肥之路有望了。再说回工作上的，从之前使用 <code>vSphere</code> 以及 <code>OpenStack</code> 较多，现在直接接触的是底层的 <code>KVM</code>，连中间的 <code>libvirt</code> 都跳过了，可能一开始的压力会比较大。自认学习东西还是比较快的，希望能尽快的熟悉起来。其次是工作环境是 Linux，这个倒是没什么不习惯，毕竟作为曾经装过<strong>黑苹果</strong>以及邪教—— <strong>Arch Linux</strong> 的人儿，日常使用 Linux 还是没什么大问题的。为难的反而是全英的语言环境以及各种各样内网权限及 Application，这个可是要花大量时间去摸索学习的。并且自己之前也没有接触到 power 架构的机器，也是一个新东西需要我去认识。不过需要花大力气的应该还是英语了，只有填充自己的词汇量，才能阅读各种英语文档，慢慢来吧。然后没想到配备的电脑是今年的 X1 Carbon，嗯，我不会说我当时是压抑着内心兴奋的心情的。整个入职体验真是 perfect。</p><p>　　然后入职前夕自己的生日也已经过了，但是在周五的月度生日会上还是看到了自己的大名，挺温暖的。第一周虽然忙忙碌碌，琐事也有，还需要接下来成体系的去学习，接着再好好的逛逛公司楼下的大商城，以此达到劳逸结合吧。毕竟现在既不追剧，又不玩网游，剩下的娱乐也就是看看电影以及偶尔逛逛了，更多时候可能的是宅在家里充实自己，感觉自己已经和同龄人有点脱节了。</p><p>　　第一周已经过去了，希望接下来自己也努力追赶上脚步，融入团队来分担工作。写了这么久，好像也没说出公司名称，只是觉得等证明了自己，至少是过了实习期，才有那个资格说出来吧。而那时，应该是到年终自我总结的时候了。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a><strong>结尾</strong></h2><p>　　一个多月没有接触到博客，这篇也只是有感而发。接下来的日子可能会在压力与飞跃中成长。很欣慰自己在朝着好的方向发展，很庆幸自己知道自己要干什么，即便无法预知未来，但是至少现在过的很开心，能将自己的兴趣转换成工作，这已经令我很满意了。只是看着两鬓的白发，以及永远一百多一点的体重，真的是要心疼自己了。不能再废寝忘食，也该多出去走走看看大千世界，好好享受生活吧~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　荒废了一个多月的博客，现在总算是有点时间再拾起来了。这一个月忙碌着，也颓废着，发生的事情太多，让我自己都感到意外。离开了广州，来到了帝都，算是开启了人生的新篇章。今后可能也不能每周更新博客，而是无定时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="essay" scheme="https://www.ananasyu.top/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins 容器实现 DooD 模式</title>
    <link href="https://www.ananasyu.top/posts/Jenkins-DooD.html"/>
    <id>https://www.ananasyu.top/posts/Jenkins-DooD.html</id>
    <published>2018-06-01T12:00:00.000Z</published>
    <updated>2018-06-05T02:56:34.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　Docker 将容器与宿主机隔离开来，虽然保证了一定的安全性，但与前些天发布的 <a href="https://katacontainers.io/" target="_blank" rel="noopener">Kata Containers</a> 相比，基于 <code>cgroup</code> 和 <code>namespace</code> 的 Docker 还是存在恶意用户通过”逃离”容器来获取使用宿主机内核的权限和共享容器。而 Kata 试图为每个容器或 pod 提供各自的轻量级虚拟机和微型内核，旨在提供容器的速度，又兼具虚拟机的安全性。借助专用的微型内核，提供了比搭载在同一个内核上的容器更有效地隔离内存、I/O 和网络等功能的机制。</p><p>　　由于 Docker 容器无法直接调用执行宿主机的命令，尽管并不推荐容器做这些事，但有时候为了方便（特别是测试环境），就需要采取某些手段将宿主机暴露给容器使用了。比如在运用 Docker 搭建 Jenkins CI 平台的时候，要想让 Jenkins 能够执行宿主机的 Docker 命令，要么是将宿主机作为 Slave 节点添加进去，要么是将宿主机的 socket 文件暴露给它使用，显然第二种方式更加便捷高效。</p><p>　　那么接下来就使用 DooD 模式，来让 Jenkins 拥有执行宿主机 Docker 命令的能力吧。</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Jenkins-DooD/JenkinsDocker.jpg" alt=""><br></div><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　要想实现容器使用 docker 命令有两种方式，区别在于环境是否与宿主隔离开来，它们分别是 <code>DinD</code> 和 <code>DooD</code>，另外通过配置端口使用HTTP通信最不安全，因此不做描述。</p><ul><li><strong>DinD</strong>：DinD 即 <code>Docker-in-Docker</code> ，是指在容器中安装一个完整的隔离的 Docker ，并在启动容器时添加 <code>–privileged</code> 参数获取完整的 Root 权限。然而这种方法无法共享宿主机 cache，相当于和主机独立开来。</li><li><strong>DooD</strong>：DooD 即 <code>Docker-outside-of-Docker</code> ，在启动容器时通过 <code>-v /var/run/docker.sock:/var/run/docker.sock</code> 将 sock 文件映射到容器当中，当容器使用 docker 命令的时候，这些操作都将转移到宿主机中进行实际操作。</li></ul><h3 id="Jenkins-实现-DooD"><a href="#Jenkins-实现-DooD" class="headerlink" title="Jenkins 实现 DooD"></a>Jenkins 实现 DooD</h3><p>　　Docker 可以快速的部署 Jenkins-Master 节点，但在容器中又让 Jenkins 无法自由的操纵宿主机系统。由于我的 Rally 以及 Tempest 都已经进行容器化，因此让 Jenkins 去调用宿主机执行 Docker 命令最适合不过。</p><h6 id="修改-Dockerfile-文件"><a href="#修改-Dockerfile-文件" class="headerlink" title="修改 Dockerfile 文件"></a>修改 Dockerfile 文件</h6><p>　　可以直接 <code>FROM</code> 官方的 Jenkins 镜像，在此基础上修改，但我喜欢从头再来，于是从 Github 克隆一份自己修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/jenkinsci/docker.git</span><br><span class="line">$ vim docker/Dockerfile</span><br></pre></td></tr></table></figure><p>　　添加 <code>sudo</code> 以及 <code>libltdl7</code> 软件包，为容器提权并使其运行 docker 命令不会因为缺失组件而报错，并配置 sudoers 文件使 jenkins 在不输入密码的情况下能使用 sudo 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk</span><br><span class="line"></span><br><span class="line">-RUN apt-get update &amp;&amp; apt-get install -y git curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">+RUN apt-get update &amp;&amp; apt-get install -y git curl sudo libltdl7 &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ARG user=jenkins</span><br><span class="line">ARG group=jenkins</span><br><span class="line">@ -19,7 +19,8 @@ ENV JENKINS_SLAVE_AGENT_PORT <span class="variable">$&#123;agent_port&#125;</span></span><br><span class="line">RUN mkdir -p <span class="variable">$JENKINS_HOME</span> \</span><br><span class="line">    &amp;&amp; chown <span class="variable">$&#123;uid&#125;</span>:<span class="variable">$&#123;gid&#125;</span> <span class="variable">$JENKINS_HOME</span> \</span><br><span class="line">    &amp;&amp; groupadd -g <span class="variable">$&#123;gid&#125;</span> <span class="variable">$&#123;group&#125;</span> \</span><br><span class="line">-   &amp;&amp; useradd -d <span class="string">"<span class="variable">$JENKINS_HOME</span>"</span> -u <span class="variable">$&#123;uid&#125;</span> -g <span class="variable">$&#123;gid&#125;</span> -m -s /bin/bash <span class="variable">$&#123;user&#125;</span></span><br><span class="line">+   &amp;&amp; useradd -d <span class="string">"<span class="variable">$JENKINS_HOME</span>"</span> -u <span class="variable">$&#123;uid&#125;</span> -g <span class="variable">$&#123;gid&#125;</span> -m -s /bin/bash <span class="variable">$&#123;user&#125;</span> \</span><br><span class="line">+   &amp;&amp; <span class="built_in">echo</span> <span class="string">"jenkins ALL=NOPASSWD: ALL"</span> &gt;&gt; /etc/sudoers</span><br></pre></td></tr></table></figure><p>　　由于官方的 Dockerfile 文件使用的 jenkins 版本太旧，因此下载最新的 stable 版本（2.107.3）并获取其 sha256 值进行替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war | sha256sum</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Saving to: ‘jenkins.war’</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</span><br></pre></td></tr></table></figure><p>　　修改 Dockerfile 中的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jenkins version being bundled in this docker image</span></span><br><span class="line">ARG JENKINS_VERSION</span><br><span class="line">-ENV JENKINS_VERSION <span class="variable">$&#123;JENKINS_VERSION:-2.60.3&#125;</span></span><br><span class="line">+ENV JENKINS_VERSION <span class="variable">$&#123;JENKINS_VERSION:-2.107.3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jenkins.war checksum, download will be validated using it</span></span><br><span class="line">-ARG JENKINS_SHA=2d71b8f87c8417f9303a73d52901a59678ee6c0eefcf7325efed6035ff39372a</span><br><span class="line">+ARG JENKINS_SHA=17a9e509bec5b16bde5b50bc7f59d5f1e458a55fe433deb86fd73b865bf89ab8</span><br></pre></td></tr></table></figure><h6 id="构建并启动容器"><a href="#构建并启动容器" class="headerlink" title="构建并启动容器"></a>构建并启动容器</h6><p>　　接下来构建镜像并启动它。其中 <code>-v /var/run/docker.sock:/var/run/docker.sock</code> 与 <code>-v $(which docker):/usr/bin/docker</code> 是实现 DooD 的关键所在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins:2.107.3 .</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins             2.107.3             0a1fd5c91cbc        About a minute ago  706MB</span><br><span class="line">openjdk             8-jdk               d480a7da7735        2 weeks ago         624MB</span><br><span class="line"></span><br><span class="line">$ docker volume create jenkins_home</span><br><span class="line">$ docker run -d \</span><br><span class="line">             -p 8080:8080 -p 50000:50000 \</span><br><span class="line">             -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">             -v $(<span class="built_in">which</span> docker):/usr/bin/docker \</span><br><span class="line">             -v jenkins_home:/var/jenkins_home \</span><br><span class="line">             --restart=always \</span><br><span class="line">             --hostname jenkins \</span><br><span class="line">             --name jenkins \</span><br><span class="line">             jenkins:2.107.3</span><br></pre></td></tr></table></figure><h6 id="验证-docker-命令"><a href="#验证-docker-命令" class="headerlink" title="验证 docker 命令"></a>验证 docker 命令</h6><p>　　进入 jenkins 容器，验证是否能正常使用 docker 命令。由于没有将 jenkins 用户加入 docker 组，所以此时需要使用 sudo 提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jenkins@jenkins:/$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tempest             18.0.0              989dd894dc00        2 days ago          927MB</span><br><span class="line">rally               0.12.1              3512077847b0        2 days ago          817MB</span><br><span class="line">jenkins             2.107.3             0a1fd5c91cbc        2 days ago          706MB</span><br><span class="line">openjdk             8-jdk               d480a7da7735        2 weeks ago         624MB</span><br><span class="line">ubuntu              16.04               0b1edfbffd27        4 weeks ago         113MB</span><br></pre></td></tr></table></figure><p>　　接下来就可以在 Jenkins 的 web 界面构建 job，然后构建步骤选择 shell 就可以调用 docker 命令进行测试及验证，或者通过其他 docker 的插件进行打包等，这里就不做过多描述。</p><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h6><p>　　实现 DooD 最好是宿主机与容器镜像选择同一种操作系统，否则可能需要增加映射的文件，并且出现未知错误。比如之前我的宿主机是 CentOS，镜像是 Ubuntu 的时候，就需要增加 <code>-v /usr/lib64/libgpgme.so.11:/usr/lib/libgpgme.so.11</code> 在启动过程中映射给容器。另外为了保险起见，同时还增加了 <code>-v /etc/sysconfig/docker:/etc/sysconfig/docker</code> 与 <code>-v /usr/bin/docker-current:/usr/bin/docker-current</code> 来保证 docker 命令执行正常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　牺牲了安全换取操作宿主机的部分权限，这个也就测试环境比较适合操作了，生产环境并不推荐这种做法。本文仅以 Jenkins 去调用宿主机 docker 命令作为实践，相信调用其他宿主机命令也是大同小异，映射宿主机相应的 sock 文件，将容器用户加入相应用户组获取权限，并安装或者挂载缺失的库文件使容器可以正常调用命令参数。不过还是担忧容器的安全性，有点期待后续 Kata Containers 的发展，能否异军突起就看社区活跃度以及后续造化了~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　Docker 将容器与宿主机隔离开来，虽然保证了一定的安全性，但与前些天发布的 &lt;a href=&quot;https://katacontainers.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kata Containers&lt;/a&gt; 相比，基于 &lt;code&gt;cgroup&lt;/code&gt; 和 &lt;code&gt;namespace&lt;/code&gt; 的 Docker 还是存在恶意用户通过”逃离”容器来获取使用宿主机内核的权限和共享容器。而 Kata 试图为每个容器或 pod 提供各自的轻量级虚拟机和微型内核，旨在提供容器的速度，又兼具虚拟机的安全性。借助专用的微型内核，提供了比搭载在同一个内核上的容器更有效地隔离内存、I/O 和网络等功能的机制。&lt;/p&gt;
&lt;p&gt;　　由于 Docker 容器无法直接调用执行宿主机的命令，尽管并不推荐容器做这些事，但有时候为了方便（特别是测试环境），就需要采取某些手段将宿主机暴露给容器使用了。比如在运用 Docker 搭建 Jenkins CI 平台的时候，要想让 Jenkins 能够执行宿主机的 Docker 命令，要么是将宿主机作为 Slave 节点添加进去，要么是将宿主机的 socket 文件暴露给它使用，显然第二种方式更加便捷高效。&lt;/p&gt;
&lt;p&gt;　　那么接下来就使用 DooD 模式，来让 Jenkins 拥有执行宿主机 Docker 命令的能力吧。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Jenkins-DooD/JenkinsDocker.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.ananasyu.top/categories/Docker/"/>
    
    
      <category term="Jenkins" scheme="https://www.ananasyu.top/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Rally 自动化测试脚本实现</title>
    <link href="https://www.ananasyu.top/posts/Rally-Automatic-Script.html"/>
    <id>https://www.ananasyu.top/posts/Rally-Automatic-Script.html</id>
    <published>2018-05-25T11:00:00.000Z</published>
    <updated>2018-07-14T05:18:02.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　Rally 作为测试 OpenStack 性能的主要项目，事实上 Rally 还可以实现云的部署和云产品的功能集成测试。Rally 主要包括一下几个部分：</p><ol><li>Deploy Engine：以类似一个插件形式的东西，和其他部署工具（比如 <code>DevStack</code>，<code>Fuel</code>，<code>Anvil</code> 等）一起工作来简化和统一部署流程。</li><li>Verification：使用 Tempset（OpenStack 社区的接口自动化测试工具）来验证已部署的 OpenStack 云环境的功能性。</li><li>Benchmark Engine：允许在云环境中制造并发负载，并进行性能基准测试。</li><li>Generate report：报表生成器，负责读取rally的测试结果（存储于数据库），生成 html、xml 等格式的报表。</li></ol><p>　　Rally 的测试用例是使用 <code>json</code> 与 <code>yaml</code> 语言编写的，阅读性很高，并且可以将多个用例合并到一个文件里执行。不过 Rally 每次执行 task 的时候都只能指定一个文件，无法批量执行多个任务，而将用例合并也不利于我们细化分析结果，这就阻止了我们自动化的脚步。</p><p>　　如果我们将所需要测试的用例分类整理好，并用脚本遍历每一个文件，将其传输给 Rally 执行测试，那么可以简化我们操作步骤及次数，这也是编写此脚本的目的。而后续将其交给 Jenkins 等 CI 平台自动构建，那么我们能将更多的精力花费去定位及解决问题的层面上，而不是去产生问题哈哈哈~~~</p><p>　　接下来将以 shell 脚本去搜集我们指定目录下的测试文件，并分类整理好以及输出统计数量给我们，最后执行所有用例。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><h3 id="统计脚本"><a href="#统计脚本" class="headerlink" title="统计脚本"></a>统计脚本</h3><p>　　统计待测试的各个组件的用例数量，完成后反馈各组件用例数量及总数量，以及各个用例的名称。下面是 Rally 场景测试中用例所包含的目录结构，我这里只挑取几个关键组件编写脚本，其他的可照猫画虎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls home/rally/<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line">authenticate  cinder     dummy  glance   heat    keystone  manila   monasca  neutron  quotas    sahara  swift  watcher   zaqar</span><br><span class="line">ceilometer    designate  ec2    gnocchi  ironic  magnum    mistral  murano   nova     requests  senlin  vm     workload</span><br></pre></td></tr></table></figure><h6 id="脚本初始化及变量定义"><a href="#脚本初始化及变量定义" class="headerlink" title="脚本初始化及变量定义"></a>脚本初始化及变量定义</h6><p>　　获取脚本所在目录并进入该目录，后续命令都以此为父目录，避免过长的绝对路径产生，也避免我们从不同地方执行脚本导致的路径问题，并做相应的准备。</p><ul><li>进入脚本所在目录作为接下来脚本工作目录；</li><li>以当前时间作为变量记录脚本执行时间；</li><li>创建存放的目录以及统计文件；</li><li>定义测试用例存放目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">time=`date +%H:%M:%S`</span><br><span class="line">mkdir -p testcase_result/<span class="variable">$time</span></span><br><span class="line">testcase_file=testcase_result/<span class="variable">$time</span>/rally_testcase.txt</span><br><span class="line">total_file=testcase_result/<span class="variable">$time</span>/rally_total.txt</span><br><span class="line">rally_task_dir=<span class="built_in">source</span>/samples/tasks/scenarios</span><br></pre></td></tr></table></figure><h6 id="各组件用例统计"><a href="#各组件用例统计" class="headerlink" title="各组件用例统计"></a>各组件用例统计</h6><p>　　分模块将各个组件的用例数量以及用例名称写入统计文件中，以 keystone 为例：</p><ul><li>查找所有 keystone文件夹下的以 yaml 结尾的用例文件（当然你也可以查找 json 的）；</li><li>统计所有用例中所有 <code>Keystone*</code> 命名的用例数量；</li><li>将用例数量写入 rally_total.txt 文件中；</li><li>使用 <code>awk</code> 将每个用例名称按顺序写入 rally_testcase.txt 文件中；</li><li>通过 <code>sed</code> 去掉用例头部的类别，其中使用正则 <code>.*</code> 匹配多个字符，<code>\.</code> 使 <code>.</code> 不被转义。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#keystone</span></span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br><span class="line">keystone_num=`grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone Testcases Number: "</span><span class="variable">$keystone_num</span> &gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone"</span> &gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Keystone.*\.//g'</span> <span class="variable">$testcase_file</span></span><br></pre></td></tr></table></figure><blockquote><p>这部分代码执行后在文件中的输出结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat rally_total.txt</span><br><span class="line">Keystone Testcases Number: 21</span><br><span class="line"></span><br><span class="line">$ cat rally_testcase.txt</span><br><span class="line">Keystone</span><br><span class="line">1: add_and_remove_user_role</span><br><span class="line">2: authenticate_user_and_validate_token</span><br><span class="line">3: create_add_and_list_user_roles</span><br><span class="line">4: create_and_delete_ec2credential</span><br><span class="line">5: create_and_delete_role</span><br><span class="line">6: create_and_delete_service</span><br><span class="line">7: create_delete_user</span><br><span class="line">8: create_and_get_role</span><br><span class="line">9: create_and_list_ec2credentials</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h6 id="统计所有组件的用例总数"><a href="#统计所有组件的用例总数" class="headerlink" title="统计所有组件的用例总数"></a>统计所有组件的用例总数</h6><p>　　将每个组件的用例总数统计并写入文本，并将上述每个用例名称最后的 <code>:</code> 去除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#total</span></span><br><span class="line"><span class="built_in">let</span> total=<span class="variable">$keystone_num</span>+<span class="variable">$glance_num</span>+<span class="variable">$nova_num</span>+……</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total Testcases Number: <span class="variable">$total</span>"</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line">sed -i <span class="string">'s/:$//'</span> <span class="variable">$testcase_file</span></span><br></pre></td></tr></table></figure><h6 id="运行用例任务脚本"><a href="#运行用例任务脚本" class="headerlink" title="运行用例任务脚本"></a>运行用例任务脚本</h6><p>　　统计完成后，使用 <code>for</code> 循环执行相应组件的任务脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run Scripts tests</span></span><br><span class="line"><span class="built_in">cd</span> testcase_result/<span class="variable">$time</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ../../rally_scripts/*.sh</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    bash <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>　　我这里只选取了基础的 <code>keystone</code> <code>glance</code> <code>nova</code> <code>neutron</code> <code>cinder</code> 五个组件做测试，整个 shell 脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">time=`date +%H:%M:%S`</span><br><span class="line">mkdir -p testcase_result/<span class="variable">$time</span></span><br><span class="line">testcase_file=testcase_result/<span class="variable">$time</span>/rally_testcase.txt</span><br><span class="line">total_file=testcase_result/<span class="variable">$time</span>/rally_total.txt</span><br><span class="line">rally_task_dir=<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line"></span><br><span class="line"><span class="comment">#keystone</span></span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br><span class="line">keystone_num=`grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone Testcases Number: "</span><span class="variable">$keystone_num</span> &gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone"</span> &gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Keystone.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#glance</span></span><br><span class="line">glance_case=`find <span class="variable">$rally_task_dir</span>/glance -name <span class="string">"*.yaml"</span>`</span><br><span class="line">glance_num=`grep -rn <span class="string">'\&lt;Glance'</span> <span class="variable">$glance_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Glance Testcases Number: "</span><span class="variable">$glance_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Glance"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Glance'</span> <span class="variable">$glance_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Glance.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nova</span></span><br><span class="line">nova_case=`find <span class="variable">$rally_task_dir</span>/nova -name <span class="string">"*.yaml"</span>`</span><br><span class="line">nova_num=`grep -rn <span class="string">'\&lt;Nova'</span> <span class="variable">$nova_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Nova Testcases Number: "</span><span class="variable">$nova_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Nova"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Nova'</span> <span class="variable">$nova_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Nova.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#neutron</span></span><br><span class="line">neutron_case=`find <span class="variable">$rally_task_dir</span>/neutron -name <span class="string">"*.yaml"</span>`</span><br><span class="line">neutron_num=`grep -rn <span class="string">'\&lt;Neutron'</span> <span class="variable">$neutron_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Neutron Testcases Number: "</span><span class="variable">$neutron_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Neutron"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Neutron'</span> <span class="variable">$neutron_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Neutron.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cinder</span></span><br><span class="line">cinder_case=`find <span class="variable">$rally_task_dir</span>/cinder -name <span class="string">"*.yaml"</span>`</span><br><span class="line">cinder_num=`grep -rn <span class="string">'\&lt;Cinder'</span> <span class="variable">$cinder_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cinder Testcases Number: "</span><span class="variable">$cinder_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cinder"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Cinder'</span> <span class="variable">$cinder_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Cinder.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#total</span></span><br><span class="line"><span class="built_in">let</span> total=<span class="variable">$keystone_num</span>+<span class="variable">$glance_num</span>+<span class="variable">$nova_num</span>+<span class="variable">$neutron_num</span>+<span class="variable">$cinder_num</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total Testcases Number: <span class="variable">$total</span>"</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line">sed -i <span class="string">'s/:$//'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Scripts tests</span></span><br><span class="line"><span class="built_in">cd</span> testcase_result/<span class="variable">$time</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ../../rally_scripts/*.sh</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    bash <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>rally_total.txt 统计结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat rally_total.txt</span><br><span class="line">Keystone Testcases Number: 21</span><br><span class="line">Glance Testcases Number: 8</span><br><span class="line">Nova Testcases Number: 63</span><br><span class="line">Neutron Testcases Number: 45</span><br><span class="line">Cinder Testcases Number: 41</span><br><span class="line">Total Testcases Number: 178</span><br></pre></td></tr></table></figure><p>　　其实该脚本可以变得更简单，那就是将 <code>rally_task_dir</code> 下的文件夹作为变量，使用 <code>for</code> 循环将变量文件夹下面的用例通过上述方式一一归档，有兴趣的话可以自己构想实现。</p><h3 id="用例执行脚本"><a href="#用例执行脚本" class="headerlink" title="用例执行脚本"></a>用例执行脚本</h3><h6 id="设定存放目录及变量"><a href="#设定存放目录及变量" class="headerlink" title="设定存放目录及变量"></a>设定存放目录及变量</h6><p>　　用来执行具体组件所有用例的测试脚本，同样以 keystone 为例：</p><ul><li>创建用来存放<font color="#0080C0"> log </font>与<font color="#0080C0"> html </font>输出的文件夹；</li><li>指定测试用例目录；</li><li>过滤 <code>keystone</code> 所有 <code>yaml</code> 类型的用例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mkdir -p keystone/&#123;<span class="built_in">log</span>,html&#125;</span><br><span class="line">rally_task_dir=../../<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br></pre></td></tr></table></figure><h6 id="用例执行及保存"><a href="#用例执行及保存" class="headerlink" title="用例执行及保存"></a>用例执行及保存</h6><p>　　使用 <code>for</code> 循环，执行 keystone 的所有用例并保存结果，</p><ul><li>执行用例并使用用例名称保存对应的 log 文件到相应目录；</li><li>读取每个用例执行结果所生成的 <code>uuid</code>，</li><li>保存每个测试用例的 html 结果。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="variable">$keystone_case</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#Create rally log</span></span><br><span class="line">    name=`<span class="built_in">echo</span> <span class="variable">$case</span> | awk -F <span class="string">"/"</span> <span class="string">'&#123;print $NF&#125;'</span> | cut -d <span class="string">"."</span> -f 1`</span><br><span class="line">    rally --<span class="built_in">log</span>-file keystone/<span class="built_in">log</span>/<span class="variable">$name</span>.<span class="built_in">log</span> task start --task <span class="variable">$case</span></span><br><span class="line">    <span class="comment">#Create rally report</span></span><br><span class="line">    uuid=`rally task status | awk <span class="string">'&#123;print $2&#125;'</span> | tr -d :`</span><br><span class="line">    rally task report <span class="variable">$uuid</span> --out keystone/html/<span class="variable">$name</span>.html</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>　　将用例保存执行即可执行所有 keystone 的用例，其他组件脚本类似，也就是换个名字而已。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　这个脚本其实也只是从外部调用 rally 命令去执行任务，简单的实现自动化的过程，比起程序内部的自动化实现还相差甚远。OpenStack 的测试涉及方面太多，还需要自己慢慢深入，业务层面理解后，摸索底层实现方式，加深自己理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　Rally 作为测试 OpenStack 性能的主要项目，事实上 Rally 还可以实现云的部署和云产品的功能集成测试。Rally 主要包括一下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Deploy Engine：以类似一个插件形式的东西，和其他部署工具（比如 &lt;code&gt;DevStack&lt;/code&gt;，&lt;code&gt;Fuel&lt;/code&gt;，&lt;code&gt;Anvil&lt;/code&gt; 等）一起工作来简化和统一部署流程。&lt;/li&gt;
&lt;li&gt;Verification：使用 Tempset（OpenStack 社区的接口自动化测试工具）来验证已部署的 OpenStack 云环境的功能性。&lt;/li&gt;
&lt;li&gt;Benchmark Engine：允许在云环境中制造并发负载，并进行性能基准测试。&lt;/li&gt;
&lt;li&gt;Generate report：报表生成器，负责读取rally的测试结果（存储于数据库），生成 html、xml 等格式的报表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　Rally 的测试用例是使用 &lt;code&gt;json&lt;/code&gt; 与 &lt;code&gt;yaml&lt;/code&gt; 语言编写的，阅读性很高，并且可以将多个用例合并到一个文件里执行。不过 Rally 每次执行 task 的时候都只能指定一个文件，无法批量执行多个任务，而将用例合并也不利于我们细化分析结果，这就阻止了我们自动化的脚步。&lt;/p&gt;
&lt;p&gt;　　如果我们将所需要测试的用例分类整理好，并用脚本遍历每一个文件，将其传输给 Rally 执行测试，那么可以简化我们操作步骤及次数，这也是编写此脚本的目的。而后续将其交给 Jenkins 等 CI 平台自动构建，那么我们能将更多的精力花费去定位及解决问题的层面上，而不是去产生问题哈哈哈~~~&lt;/p&gt;
&lt;p&gt;　　接下来将以 shell 脚本去搜集我们指定目录下的测试文件，并分类整理好以及输出统计数量给我们，最后执行所有用例。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="https://www.ananasyu.top/categories/OpenStack/"/>
    
    
      <category term="Rally" scheme="https://www.ananasyu.top/tags/Rally/"/>
    
      <category term="Shell" scheme="https://www.ananasyu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>基于 Dockerfile 构建 Rally 和 Tempest 容器镜像</title>
    <link href="https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html"/>
    <id>https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html</id>
    <published>2018-05-18T11:00:00.000Z</published>
    <updated>2018-07-14T05:18:15.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　<code>Rally</code> 和 <code>Tempest</code> 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。</p><p>　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：</p><ol><li><font color="#008844"> 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； </font></li><li><font color="#008844"> 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； </font></li><li><font color="#008844"> 易扩展可复用：将构建需求分成多步 <font color="#FF0000"> Step </font> 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 <font color="#FF0000"> Libcontainer </font> 引擎也令跨平台复用变得易如反掌； </font></li><li><font color="#008844"> 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。</font></li></ol><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　Dockerfile 作为镜像的描述文件，以简单的命令定义每一 Step 中镜像该做的事情，并将每一次步骤后的镜像 commit 为一个新镜像继续执行后续步骤。每增加一步 Step ，镜像会增加一个 layer 层，所以合理地设计及编写 Dockerfile 文件，避免镜像层次过于臃肿也是门需要思考的艺术。借此通过构建 Rally 以及 Tempest 的容器镜像，也顺便理解 Dockerfile 的文件结构及编写规范。</p><h3 id="Rally"><a href="#Rally" class="headerlink" title="Rally"></a>Rally</h3><blockquote><p>　　Rally 是一个基准测试工具，Rally 实现了自动化并统一了多个节点的 OpenStack 部署、云的验证、基准测试以及分析，以这种通用的方式去验证“ OpenStack 是如何大规模运作的？”这样的疑问，比如在数以千计的服务器下的高负载中是否正常工作。因此，可以将它作为 OpenStack CI/CD 系统的基本工具来使用，借以不断地改进 SLA（ Service-Level Agreement ）、性能和稳定性。</p></blockquote><div align="center" style="align:center"><br><font size="6">Rally 架构 </font><br><img src="https://rally.readthedocs.io/en/stable/_images/Rally-Actions.png" alt="Rally 架构" title="Rally架构"><br></div><p>　　Rally 自己提供了 Docker 镜像存储在 <a href="https://hub.docker.com/r/xrally/xrally-openstack/" title="Rally官方Docker镜像" target="_blank" rel="noopener">Docker Hub</a> 上，也可以从 Github 上下载<a href="https://github.com/openstack/rally" title="Rally源码" target="_blank" rel="noopener"> Rally 源码</a>自己修改构建。接下来结合官方的 Dockerfile 文件，自定义修改属于我们自己的 Rally 镜像。</p><h6 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定一个基础镜像进行构建。命令参数 <code>FROM &lt;image&gt;:&lt;tag&gt;</code> ，这里使用 ubuntu:16.04 作为 Rally 的基础镜像，它将作为镜像第一层完成后续步骤构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　指定作者信息。命令参数 <code>MAINTAINER &lt;name&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Rally 所需依赖包及创建相应目录。Dockerfile 使用 <code>RUN &lt;command&gt;</code> 调用系统 shell 运行相关命令，多个命令不建议分别写多个 <code>RUN</code> 指令，因为这会使镜像层次变得复杂，而是建议使用 <code>&amp;&amp;</code> 和 <code>\</code> 连接多条命令并换行书写，优化构建的逻辑结构和代码的可读性。通过下述 5 个步骤完成前期准备，其中 source 是我用来存放下载源码的目录。</p><ul><li>更新软件列表</li><li>安装依赖软件</li><li>时区改为 CST</li><li>反注释开启命令参数补齐</li><li>创建 Rally 源码下载目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils iputils-ping vim wget git-core tzdata \</span><br><span class="line">    python python-pip python-dev &amp;&amp; \</span><br><span class="line">    pip install --upgrade pip &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/rally/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载 Rally 的安装脚本并进行必要修改后进行安装，同时替换掉需要调用墙外的 js 框架文件变为我们可访问的目标地址。</p><ul><li>下载 12.0.0 的 Rally 安装文件到 <code>/home/rally/</code></li><li>替换安装版本为 12.0.0</li><li>修改 Rally 的 <code>database</code> 保存在 <code>/home/rally/data/</code></li><li>下载的源码保存在 <code>/home/rally/source/</code></li><li>安装时拷贝 Rally 命令补全文件及开启运行容器时输出相关 Info</li><li>安装 Rally</li><li>替换 googleapis 上的 <code>angular.min.js</code> 为 cloudflare 网站上面的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RUN wget -P /home/rally/ https://raw.githubusercontent.com/openstack/rally/0.12.0/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_GIT_BRANCH=.*/RALLY_GIT_BRANCH="0.12.0"/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_DATABASE_DIR=.*/RALLY_DATABASE_DIR=\/home\/rally\/data/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/SOURCEDIR="\$ORIG_WD".*/SOURCEDIR="\$ORIG_WD"\/home\/rally\/source/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'cp $SOURCEDIR/etc/motd /etc/motd'</span> &gt;&gt; /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ ! -z "$TERM" -a -r /etc/motd ] &amp;&amp; cat /etc/motd'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'source /usr/local/etc/bash_completion.d/rally.bash_completion'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    bash /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/report.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/trends.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/verification/report.html</span><br></pre></td></tr></table></figure><h6 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　拷贝 <code>build</code> 过程中指定的上下文目录文件到镜像内部。命令参数 <code>COPY &lt;src&gt;... &lt;dest&gt;</code> ，可以通过同目录下的 <code>.dockerignore</code> 忽略部分不需要传输的文件。这里我是将 Rally 自动测试的执行脚本拷贝到镜像内部，方便后续测试。</p><p>　　还有另外一个命令 <code>ADD</code> 可以理解为增强版的 <code>COPY</code> ，它不仅能将本地目录的文件拷贝到镜像中，同时还能降远程 url 的文件或目录拷贝至镜像里面，如果源文件是一个压缩包，在拷贝过程中还会自动解压。它的命令参数与 <code>COPY</code> 无二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY . /home/rally/</span><br></pre></td></tr></table></figure><h6 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　安装完毕后清理 apt 以及 pip 安装过程中的缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">    rm -rf /root/.cache/</span><br></pre></td></tr></table></figure><h6 id="Step-7"><a href="#Step-7" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　建立存放数据库的 <code>/home/rally/data/</code> 目录并重新创建 Rally 的数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /home/rally/data &amp;&amp; \</span><br><span class="line">    rally db recreate</span><br></pre></td></tr></table></figure><h6 id="Step-8"><a href="#Step-8" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　更改镜像工作目录，使得启动镜像后在 <code>/home/rally/</code> 目录执行命令等。命令参数 <code>WORKDIR &lt;dir&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /home/rally</span><br></pre></td></tr></table></figure><h6 id="Step-9"><a href="#Step-9" class="headerlink" title="Step 9"></a>Step 9</h6><p>　　为了令测试数据持久化，将镜像数据存储文件夹挂载到宿主机，命令参数 <code>VLOUME [&quot;&lt;dir&gt;&quot;]</code> 。启动容器的时候会在 <code>/var/lib/docker/volumes/</code> 下创建一个随机命名的文件夹并将其挂载关联，也可在启动时通过 <code>-v</code> 挂载到指定目录，便于数据的查看及持久化保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/home/rally"</span>]</span><br></pre></td></tr></table></figure><h6 id="Step-10"><a href="#Step-10" class="headerlink" title="Step 10"></a>Step 10</h6><p>　　官方是以 <code>ENTRYPOINT [&quot;rally&quot;]</code> 作为容器启动时的默认命令。我们启动容器时指定的命令都将作为参数传给 <code>rally</code> 调用，不会被重写覆盖，这也导致我们无法直接进入容器内部去执行其他操作，解决办法是在使用 <code>docker run</code> 的时候用 <code>--rm --entrypoint /bin/bash</code> 临时替换。测试过程中我喜欢进去容器内部操作，因此摒弃 <code>ENTRYPOINT</code> 而用 <code>CMD</code> 命令，它允许我们启动时用别的命令覆盖，进行其他操作。两者的命令参数为 <code>ENTRYPOINT/CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 。一个Dockerfile文件仅允许一个<code>ENTRYPOINT</code> 和 <code>CMD</code> 存在，多次存在的话只有最后一次会生效。当两者同时存在的情况下，可以使用 <code>CMD</code> 给 <code>ENTRYPOINT</code> 传参，比如 <code>ENTRYPOINT [&quot;rally&quot;]</code> <code>CMD [&quot;--version&quot;]</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此一个 Rally 的 Dockerfile 文件编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Rally 容器镜像。构建完毕后可通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t rally_container:0.12.0 .</span><br></pre></td></tr></table></figure><h6 id="附录：Rally-Documentation"><a href="#附录：Rally-Documentation" class="headerlink" title="附录：Rally Documentation "></a><font color="#FF0000">附录：Rally Documentation </font></h6><div class="row">    <embed src="https://media.readthedocs.org/pdf/rally/stable/rally.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Tempest"><a href="#Tempest" class="headerlink" title="Tempest"></a>Tempest</h3><blockquote><p>　　Tempest 是 Openstack 的集成测试框架，对于验证 OpenStack 部署，包含了基本组件的 API 测试、场景测试和单元测试。Tempest 对 Openstack 终端发起一系列 API 请求，并且对终端的响应进行验证。它可以验证代码的正确性，使得 OpenStack 相关测试效率得到大幅度提升，已经成为 OpenStack 项目中不可或缺的组成部分。</p></blockquote><div align="center" style="align:center"><br><font size="6">Tempest 代码架构 <br></font><br><img src="https://www.ibm.com/developerworks/cn/cloud/library/1403_liuyu_openstacktempest/image005.jpg" alt="Tempest 代码架构" title="Tempest 代码架构"><br><br></div><p>　　Tempest 没有官方的 Docker 镜像提供给我们参考和使用，我们可以按照自己安装过程中的步骤配置 Dockerfile 文件。此处仅记录我安装习惯的配置。</p><h6 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定 ubuntu:16.04 作为基础镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　备注作者信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Tempest 依赖软件包、修改时区、反注释命令补全功能，创建源码下载目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils vim git wget curl gcc tzdata \</span><br><span class="line">    python-dev python-libxml2 python-setuptools \</span><br><span class="line">    libxml2-dev libxslt-dev lib32z1-dev libssl-dev libxslt1-dev libsasl2-dev libsqlite3-dev libldap2-dev libffi-dev &amp;&amp; \</span><br><span class="line">    easy_install pip &amp;&amp; \</span><br><span class="line">    pip install --upgrade setuptools &amp;&amp; \</span><br><span class="line">    pip install xunit2testrail junitxml virtualenv python-openstackclient &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/tempest/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4-1"><a href="#Step-4-1" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载版本为 18.0.0 的 Tempest 源码，<code>pip</code> 安装所需依赖组件及调试所需的 <code>ipdb</code> ，最后安装 Tempest。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    git <span class="built_in">clone</span> -b 18.0.0 https://git.openstack.org/openstack/tempest ./ &amp;&amp; \</span><br><span class="line">    pip install -r ./requirements.txt &amp;&amp; \</span><br><span class="line">    pip install -r ./<span class="built_in">test</span>-requirements.txt &amp;&amp; \</span><br><span class="line">    pip install nose tox ipdb &amp;&amp; \</span><br><span class="line">    pip install .</span><br></pre></td></tr></table></figure><h6 id="Step-5-1"><a href="#Step-5-1" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　生成配置文件样本并拷贝一份以便后续配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    tox -egenconfig &amp;&amp; \</span><br><span class="line">    cp etc/accounts.yaml.sample etc/accounts.yaml &amp;&amp; \</span><br><span class="line">    cp etc/tempest.conf.sample etc/tempest.conf</span><br></pre></td></tr></table></figure><h6 id="Step-6-1"><a href="#Step-6-1" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　在 <code>/home/tempest/workdir</code> 文件夹中初始化 Tempest。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN tempest init /home/tempest/workdir</span><br></pre></td></tr></table></figure></p><h6 id="Step-7-1"><a href="#Step-7-1" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　指定 Tempest 工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /root/tempest/workdir</span><br></pre></td></tr></table></figure><h6 id="Step-8-1"><a href="#Step-8-1" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　指定容器启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此 Tempest 的 Dockerfile 文件也已编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Tempest 镜像。构建完毕后通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t tempest_container:18.0.0 .</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>　　通过 Dockerfile 构建 Rally 以及 Tempest 镜像，不仅能让我们快速的搭建测试环境，也利于持续集成及持续交付过程中节省时间，统一及标准化环境。而且与 OpenStack 隔离开来，更是减少了测试过程中的互相干扰。并且 <code>Docker volume</code> 的存在也确保了测试输出结果能同步保存至宿主机并持久化。</p><p>　　最后将 Rally 以及 Tempest 的容器镜像上传至 <code>Docker Hub</code> 或者保存至本地 <code>registry</code> ，方便后续使用。</p><ul><li><a href="https://hub.docker.com/r/ananasyuu/docker_rally/" target="_blank" rel="noopener">Rally 镜像的 Docker Hub 链接</a></li><li><a href="https://hub.docker.com/r/ananasyuu/docker_tempest/" target="_blank" rel="noopener">Tempest 镜像的 Docker Hub 链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　&lt;code&gt;Rally&lt;/code&gt; 和 &lt;code&gt;Tempest&lt;/code&gt; 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。&lt;/p&gt;
&lt;p&gt;　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 易扩展可复用：将构建需求分成多步 &lt;font color=&quot;#FF0000&quot;&gt; Step &lt;/font&gt; 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 &lt;font color=&quot;#FF0000&quot;&gt; Libcontainer &lt;/font&gt; 引擎也令跨平台复用变得易如反掌； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。&lt;/font&gt;

&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.ananasyu.top/categories/Docker/"/>
    
    
      <category term="Rally" scheme="https://www.ananasyu.top/tags/Rally/"/>
    
      <category term="Dockerfile" scheme="https://www.ananasyu.top/tags/Dockerfile/"/>
    
      <category term="Tempest" scheme="https://www.ananasyu.top/tags/Tempest/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Hexo !</title>
    <link href="https://www.ananasyu.top/posts/Hello-Hexo.html"/>
    <id>https://www.ananasyu.top/posts/Hello-Hexo.html</id>
    <published>2018-05-10T09:50:30.000Z</published>
    <updated>2018-07-14T06:12:11.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/HelloHexo.jpg" alt=""><br></div><a id="more"></a><p>　</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　回想起高二高三那时折腾塞班系统的固件，为 <font color="#66CDAA">Nokia N79</font> 美化及优化原生系统；从高三暑假才拥有属于自己的电脑的小白到大学当网管头头带领十几个人穿梭在男男女女的学生宿舍之中，解决 Ta 们使用校园网遇到的各种问题（然而也没有找到另一半Ｔ▽Ｔ）；再到现如今藏匿在<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%B9%BF%E5%B7%9E%E7%A0%94%E7%A9%B6%E9%99%A2/92623" title="中国电信广州研究院" target="_blank" rel="noopener">中国电信广州研究院</a>从事着虚拟化及云计算测试相关。发现自己的涉猎面越来越广，无论技术还是兴趣~~~</p><p>　　没事哼哼小曲儿，凭着自己头脑里的想法去尝试改进工作中的流程，能将工作融入到生活中是我希望达到的状态。作为一个测试人员需要学习的知识还是很多，产品熟悉度及工具的创新及运用也不是件容易事。希望接下来的博客能较多的涉猎以下内容，鞭策自己向着更深更好的方向前进。</p><ul><li><div><img style="margin:0px 6px 7px 0px" src="https://wiki.openstack.org/favicon.ico" width="27" height="27"> <a href="https://www.openstack.org/" target="_blank" rel="noopener"><font size="5">OpenStack</font></a></div></li><li><div><img style="margin:0px 1px 12px -5px" src="https://www.docker.com/favicon.ico" width="36" height="36"> <a href="https://www.docker.com/" target="_blank" rel="noopener"><font size="5">Docker</font></a></div></li><li><div><img style="margin:0px 10px 10px 0px" src="https://jenkins.io/sites/default/files/jenkins_favicon.ico" width="27" height="27"> <a href="https://jenkins.io/" target="_blank" rel="noopener"><font size="5">Jenkins</font></a></div></li><li><div><img style="margin:0px 5px 6px 0px" src="https://www.python.org/static/favicon.ico" width="27" height="27"> <a href="https://www.python.org/" target="_blank" rel="noopener"><font size="5">Python</font></a><br><br></div></li></ul><p>　　趁着现在热情正盛，工作中的 idea 和技术实现还没有忘记的时候及时记录下来，弥补日常工作总结中的不足。就怕前期高产，等到脑中的想法被挖空得差不多了之后就写不出东西了，走走看看呗。接下来的日子里，立个目标——每周一篇以上的文章。等到以后过上了佛系养生亦或者工作忙碌的无暇更新的时候，再回头看看自己曾经写下的经历、不足以及成长！！！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>　　折腾了几天下来，博客的雏形就暂时定这样子吧。使用 <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 搭建博客还是挺简单的。当看到这个博客展现在眼前的时候，心情确实有点激动，也特别感谢 <a href="http://litten.me" title="Litten的博客" target="_blank" rel="noopener">Litten</a> 制作的主题 <a href="https://github.com/litten/hexo-theme-yilia" title="Yilia主题" target="_blank" rel="noopener">Yilia</a>，非常喜欢这种简洁的双栏主题，交互方便又美观大方。说实在的，第一次尝试用 <a href="http://wowubuntu.com/markdown/index.html" title="Markdown语法中文完整版" target="_blank" rel="noopener">Markdown</a> 语法写文章，而且好久没执笔写过东西了，以后再慢慢改进排版吧！</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/HelloHexoBye.jpg" alt=""><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/HelloHexo.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="essay" scheme="https://www.ananasyu.top/tags/essay/"/>
    
  </entry>
  
</feed>
