<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnanasYu的博客</title>
  
  <subtitle>寡言少语，生人勿近</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ananasyu.top/"/>
  <updated>2018-05-25T07:41:28.682Z</updated>
  <id>https://www.ananasyu.top/</id>
  
  <author>
    <name>Ananas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rally+Automatic+Script</title>
    <link href="https://www.ananasyu.top/posts/Rally-Automatic-Script.html"/>
    <id>https://www.ananasyu.top/posts/Rally-Automatic-Script.html</id>
    <published>2018-05-25T11:00:00.000Z</published>
    <updated>2018-05-25T07:41:28.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　Rally 作为测试 OpenStack 性能的主要项目，事实上 Rally 还可以实现云的部署和云产品的功能集成测试。Rally 主要包括一下几个部分：</p><ol><li>Deploy Engine：以类似一个插件形式的东西，和其他部署工具（比如 <code>DevStack</code>，<code>Fuel</code>，<code>Anvil</code> 等）一起工作来简化和统一部署流程。</li><li>Verification：使用 Tempset（OpenStack 社区的接口自动化测试工具）来验证已部署的 OpenStack 云环境的功能性。</li><li>Benchmark Engine：允许在云环境中制造并发负载，并进行性能基准测试。</li><li>Generate report：报表生成器，负责读取rally的测试结果（存储于数据库），生成 html、xml 等格式的报表。</li></ol><p>　　Rally 的测试用例是使用 <code>json</code> 与 <code>yaml</code> 语言编写的，阅读性很高，并且可以将多个用例合并到一个文件里执行。不过 Rally 每次执行 task 的时候都只能指定一个文件，无法批量执行多个任务，而将用例合并也不利于我们细化分析结果，这就阻止了我们自动化的脚步。</p><p>　　如果我们将所需要测试的用例分类整理好，并用脚本遍历每一个文件，将其传输给 Rally 执行测试，那么可以简化我们操作步骤及次数，这也是编写此脚本的目的。而后续将其交给 Jenkins 等 CI 平台自动构建，那么我们能将更多的精力花费去定位及解决问题的层面上，而不是去产生问题哈哈哈~~~</p><p>　　接下来将以 shell 脚本去搜集我们指定目录下的测试文件，并分类整理好以及输出统计数量给我们，最后执行所有用例。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><h3 id="统计脚本"><a href="#统计脚本" class="headerlink" title="统计脚本"></a>统计脚本</h3><p>　　统计待测试的各个组件的用例数量，完成后反馈各组件用例数量及总数量，以及各个用例的名称。下面是 Rally 场景测试中用例所包含的目录结构，我这里只挑取几个关键组件编写脚本，其他的可照猫画虎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls home/rally/<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line">authenticate  cinder     dummy  glance   heat    keystone  manila   monasca  neutron  quotas    sahara  swift  watcher   zaqar</span><br><span class="line">ceilometer    designate  ec2    gnocchi  ironic  magnum    mistral  murano   nova     requests  senlin  vm     workload</span><br></pre></td></tr></table></figure><h6 id="脚本初始化及变量定义"><a href="#脚本初始化及变量定义" class="headerlink" title="脚本初始化及变量定义"></a>脚本初始化及变量定义</h6><p>　　获取脚本所在目录并进入该目录，后续命令都以此为父目录，避免过长的绝对路径产生，也避免我们从不同地方执行脚本导致的路径问题，并做相应的准备。</p><ul><li>进入脚本所在目录作为接下来脚本工作目录；</li><li>以当前时间作为变量记录脚本执行时间；</li><li>创建存放的目录以及统计文件；</li><li>定义测试用例存放目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">time=`date +%H:%M:%S`</span><br><span class="line">mkdir -p testcase_result/<span class="variable">$time</span></span><br><span class="line">testcase_file=testcase_result/<span class="variable">$time</span>/rally_testcase.txt</span><br><span class="line">total_file=testcase_result/<span class="variable">$time</span>/rally_total.txt</span><br><span class="line">rally_task_dir=<span class="built_in">source</span>/samples/tasks/scenarios</span><br></pre></td></tr></table></figure><h6 id="各组件用例统计"><a href="#各组件用例统计" class="headerlink" title="各组件用例统计"></a>各组件用例统计</h6><p>　　分模块将各个组件的用例数量以及用例名称写入统计文件中，以 keystone 为例：</p><ul><li>查找所有 keystone文件夹下的以 yaml 结尾的用例文件（当然你也可以查找 json 的）；</li><li>统计所有用例中所有 <code>Keystone*</code> 命名的用例数量；</li><li>将用例数量写入 rally_total.txt 文件中；</li><li>使用 <code>awk</code> 将每个用例名称按顺序写入 rally_testcase.txt 文件中；</li><li>通过 <code>sed</code> 去掉用例头部的类别，其中使用正则 <code>.*</code> 匹配多个字符，<code>\.</code> 使 <code>.</code> 不被转义。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#keystone</span></span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br><span class="line">keystone_num=`grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone Testcases Number: "</span><span class="variable">$keystone_num</span> &gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone"</span> &gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Keystone.*\.//g'</span> <span class="variable">$testcase_file</span></span><br></pre></td></tr></table></figure><blockquote><p>这部分代码执行后在文件中的输出结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat rally_total.txt</span><br><span class="line">Keystone Testcases Number: 21</span><br><span class="line"></span><br><span class="line">$ cat rally_testcase.txt</span><br><span class="line">Keystone</span><br><span class="line">1: add_and_remove_user_role</span><br><span class="line">2: authenticate_user_and_validate_token</span><br><span class="line">3: create_add_and_list_user_roles</span><br><span class="line">4: create_and_delete_ec2credential</span><br><span class="line">5: create_and_delete_role</span><br><span class="line">6: create_and_delete_service</span><br><span class="line">7: create_delete_user</span><br><span class="line">8: create_and_get_role</span><br><span class="line">9: create_and_list_ec2credentials</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h6 id="统计所有组件的用例总数"><a href="#统计所有组件的用例总数" class="headerlink" title="统计所有组件的用例总数"></a>统计所有组件的用例总数</h6><p>　　将每个组件的用例总数统计并写入文本，并将上述每个用例名称最后的 <code>:</code> 去除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#total</span></span><br><span class="line"><span class="built_in">let</span> total=<span class="variable">$keystone_num</span>+<span class="variable">$glance_num</span>+<span class="variable">$nova_num</span>+……</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total Testcases Number: <span class="variable">$total</span>"</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line">sed -i <span class="string">'s/:$//'</span> <span class="variable">$testcase_file</span></span><br></pre></td></tr></table></figure><h6 id="运行用例任务脚本"><a href="#运行用例任务脚本" class="headerlink" title="运行用例任务脚本"></a>运行用例任务脚本</h6><p>　　统计完成后，使用 <code>for</code> 循环执行相应组件的任务脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run Scripts tests</span></span><br><span class="line"><span class="built_in">cd</span> testcase_result/<span class="variable">$time</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ../../rally_scripts/*.sh</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    bash <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>　　我这里只选取了基础的 <code>keystone</code> <code>glance</code> <code>nova</code> <code>neutron</code> <code>cinder</code> 五个组件做测试，整个 shell 脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">time=`date +%H:%M:%S`</span><br><span class="line">mkdir -p testcase_result/<span class="variable">$time</span></span><br><span class="line">testcase_file=testcase_result/<span class="variable">$time</span>/rally_testcase.txt</span><br><span class="line">total_file=testcase_result/<span class="variable">$time</span>/rally_total.txt</span><br><span class="line">rally_task_dir=<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line"></span><br><span class="line"><span class="comment">#keystone</span></span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br><span class="line">keystone_num=`grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone Testcases Number: "</span><span class="variable">$keystone_num</span> &gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Keystone"</span> &gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Keystone'</span> <span class="variable">$keystone_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Keystone.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#glance</span></span><br><span class="line">glance_case=`find <span class="variable">$rally_task_dir</span>/glance -name <span class="string">"*.yaml"</span>`</span><br><span class="line">glance_num=`grep -rn <span class="string">'\&lt;Glance'</span> <span class="variable">$glance_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Glance Testcases Number: "</span><span class="variable">$glance_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Glance"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Glance'</span> <span class="variable">$glance_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Glance.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nova</span></span><br><span class="line">nova_case=`find <span class="variable">$rally_task_dir</span>/nova -name <span class="string">"*.yaml"</span>`</span><br><span class="line">nova_num=`grep -rn <span class="string">'\&lt;Nova'</span> <span class="variable">$nova_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Nova Testcases Number: "</span><span class="variable">$nova_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Nova"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Nova'</span> <span class="variable">$nova_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Nova.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#neutron</span></span><br><span class="line">neutron_case=`find <span class="variable">$rally_task_dir</span>/neutron -name <span class="string">"*.yaml"</span>`</span><br><span class="line">neutron_num=`grep -rn <span class="string">'\&lt;Neutron'</span> <span class="variable">$neutron_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Neutron Testcases Number: "</span><span class="variable">$neutron_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Neutron"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Neutron'</span> <span class="variable">$neutron_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Neutron.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cinder</span></span><br><span class="line">cinder_case=`find <span class="variable">$rally_task_dir</span>/cinder -name <span class="string">"*.yaml"</span>`</span><br><span class="line">cinder_num=`grep -rn <span class="string">'\&lt;Cinder'</span> <span class="variable">$cinder_case</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cinder Testcases Number: "</span><span class="variable">$cinder_num</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cinder"</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">grep -rn <span class="string">'\&lt;Cinder'</span> <span class="variable">$cinder_case</span> | awk <span class="string">'&#123;print NR":",$2&#125;'</span> &gt;&gt; <span class="variable">$testcase_file</span></span><br><span class="line">sed -i <span class="string">'s/Cinder.*\.//g'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#total</span></span><br><span class="line"><span class="built_in">let</span> total=<span class="variable">$keystone_num</span>+<span class="variable">$glance_num</span>+<span class="variable">$nova_num</span>+<span class="variable">$neutron_num</span>+<span class="variable">$cinder_num</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total Testcases Number: <span class="variable">$total</span>"</span> &gt;&gt; <span class="variable">$total_file</span></span><br><span class="line">sed -i <span class="string">'s/:$//'</span> <span class="variable">$testcase_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Scripts tests</span></span><br><span class="line"><span class="built_in">cd</span> testcase_result/<span class="variable">$time</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ../../rally_scripts/*.sh</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    bash <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>rally_total.txt 统计结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat rally_total.txt</span><br><span class="line">Keystone Testcases Number: 21</span><br><span class="line">Glance Testcases Number: 8</span><br><span class="line">Nova Testcases Number: 63</span><br><span class="line">Neutron Testcases Number: 45</span><br><span class="line">Cinder Testcases Number: 41</span><br><span class="line">Total Testcases Number: 178</span><br></pre></td></tr></table></figure><p>　　其实该脚本可以变得更简单，那就是将 <code>rally_task_dir</code> 下的文件夹作为变量，使用 <code>for</code> 循环将变量文件夹下面的用例通过上述方式一一归档，有兴趣的话可以自己构想实现。</p><h3 id="用例执行脚本"><a href="#用例执行脚本" class="headerlink" title="用例执行脚本"></a>用例执行脚本</h3><h6 id="设定存放目录及变量"><a href="#设定存放目录及变量" class="headerlink" title="设定存放目录及变量"></a>设定存放目录及变量</h6><p>　　用来执行具体组件所有用例的测试脚本，同样以 keystone 为例：</p><ul><li>创建用来存放<font color="#0080C0"> log </font>与<font color="#0080C0"> html </font>输出的文件夹；</li><li>指定测试用例目录；</li><li>过滤 <code>keystone</code> 所有 <code>yaml</code> 类型的用例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mkdir -p keystone/&#123;<span class="built_in">log</span>,html&#125;</span><br><span class="line">rally_task_dir=../../<span class="built_in">source</span>/samples/tasks/scenarios</span><br><span class="line">keystone_case=`find <span class="variable">$rally_task_dir</span>/keystone -name <span class="string">"*.yaml"</span>`</span><br></pre></td></tr></table></figure><h6 id="用例执行及保存"><a href="#用例执行及保存" class="headerlink" title="用例执行及保存"></a>用例执行及保存</h6><p>　　使用 <code>for</code> 循环，执行 keystone 的所有用例并保存结果，</p><ul><li>执行用例并使用用例名称保存对应的 log 文件到相应目录；</li><li>读取每个用例执行结果所生成的 <code>uuid</code>，</li><li>保存每个测试用例的 html 结果。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="variable">$keystone_case</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#Create rally log</span></span><br><span class="line">    name=`<span class="built_in">echo</span> <span class="variable">$case</span> | awk -F <span class="string">"/"</span> <span class="string">'&#123;print $NF&#125;'</span> | cut -d <span class="string">"."</span> -f 1`</span><br><span class="line">    rally --<span class="built_in">log</span>-file keystone/<span class="built_in">log</span>/<span class="variable">$name</span>.<span class="built_in">log</span> task start --task <span class="variable">$case</span></span><br><span class="line">    <span class="comment">#Create rally report</span></span><br><span class="line">    uuid=`rally task status | awk <span class="string">'&#123;print $2&#125;'</span> | tr -d :`</span><br><span class="line">    rally task report <span class="variable">$uuid</span> --out keystone/html/<span class="variable">$name</span>.html</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>　　将用例保存执行即可执行所有 keystone 的用例，其他组件脚本类似，也就是换个名字而已。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　这个脚本其实也只是从外部调用 rally 命令去执行任务，简单的实现自动化的过程，比起程序内部的自动化实现还相差甚远。OpenStack 的测试涉及方面太多，还需要自己慢慢深入，业务层面理解后，摸索底层实现方式，加深自己理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　Rally 作为测试 OpenStack 性能的主要项目，事实上 Rally 还可以实现云的部署和云产品的功能集成测试。Rally 主要包括一下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Deploy Engine：以类似一个插件形式的东西，和其他部署工具（比如 &lt;code&gt;DevStack&lt;/code&gt;，&lt;code&gt;Fuel&lt;/code&gt;，&lt;code&gt;Anvil&lt;/code&gt; 等）一起工作来简化和统一部署流程。&lt;/li&gt;
&lt;li&gt;Verification：使用 Tempset（OpenStack 社区的接口自动化测试工具）来验证已部署的 OpenStack 云环境的功能性。&lt;/li&gt;
&lt;li&gt;Benchmark Engine：允许在云环境中制造并发负载，并进行性能基准测试。&lt;/li&gt;
&lt;li&gt;Generate report：报表生成器，负责读取rally的测试结果（存储于数据库），生成 html、xml 等格式的报表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　Rally 的测试用例是使用 &lt;code&gt;json&lt;/code&gt; 与 &lt;code&gt;yaml&lt;/code&gt; 语言编写的，阅读性很高，并且可以将多个用例合并到一个文件里执行。不过 Rally 每次执行 task 的时候都只能指定一个文件，无法批量执行多个任务，而将用例合并也不利于我们细化分析结果，这就阻止了我们自动化的脚步。&lt;/p&gt;
&lt;p&gt;　　如果我们将所需要测试的用例分类整理好，并用脚本遍历每一个文件，将其传输给 Rally 执行测试，那么可以简化我们操作步骤及次数，这也是编写此脚本的目的。而后续将其交给 Jenkins 等 CI 平台自动构建，那么我们能将更多的精力花费去定位及解决问题的层面上，而不是去产生问题哈哈哈~~~&lt;/p&gt;
&lt;p&gt;　　接下来将以 shell 脚本去搜集我们指定目录下的测试文件，并分类整理好以及输出统计数量给我们，最后执行所有用例。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="https://www.ananasyu.top/categories/OpenStack/"/>
    
    
      <category term="Rally" scheme="https://www.ananasyu.top/tags/Rally/"/>
    
      <category term="Shell" scheme="https://www.ananasyu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>基于 Dockerfile 构建 Rally 和 Tempest 容器镜像</title>
    <link href="https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html"/>
    <id>https://www.ananasyu.top/posts/Build-Rally-and-Tempest-based-on-Dockerfile.html</id>
    <published>2018-05-18T11:00:00.000Z</published>
    <updated>2018-05-21T10:43:13.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　<code>Rally</code> 和 <code>Tempest</code> 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。</p><p>　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：</p><ol><li><font color="#008844"> 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； </font></li><li><font color="#008844"> 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； </font></li><li><font color="#008844"> 易扩展可复用：将构建需求分成多步 <font color="#FF0000"> Step </font> 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 <font color="#FF0000"> Libcontainer </font> 引擎也令跨平台复用变得易如反掌； </font></li><li><font color="#008844"> 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。</font></li></ol><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　Dockerfile 作为镜像的描述文件，以简单的命令定义每一 Step 中镜像该做的事情，并将每一次步骤后的镜像 commit 为一个新镜像继续执行后续步骤。每增加一步 Step ，镜像会增加一个 layer 层，所以合理地设计及编写 Dockerfile 文件，避免镜像层次过于臃肿也是门需要思考的艺术。借此通过构建 Rally 以及 Tempest 的容器镜像，也顺便理解 Dockerfile 的文件结构及编写规范。</p><h3 id="Rally"><a href="#Rally" class="headerlink" title="Rally"></a>Rally</h3><blockquote><p>　　Rally 是一个基准测试工具，Rally 实现了自动化并统一了多个节点的 OpenStack 部署、云的验证、基准测试以及分析，以这种通用的方式去验证“ OpenStack 是如何大规模运作的？”这样的疑问，比如在数以千计的服务器下的高负载中是否正常工作。因此，可以将它作为 OpenStack CI/CD 系统的基本工具来使用，借以不断地改进 SLA（ Service-Level Agreement ）、性能和稳定性。</p></blockquote><div align="center" style="align:center"><br><font size="6">Rally 架构 </font><br><img src="https://rally.readthedocs.io/en/stable/_images/Rally-Actions.png" alt="Rally 架构" title="Rally架构"><br></div><p>　　Rally 自己提供了 Docker 镜像存储在 <a href="https://hub.docker.com/r/xrally/xrally-openstack/" title="Rally官方Docker镜像" target="_blank" rel="noopener">Docker Hub</a> 上，也可以从 Github 上下载<a href="https://github.com/openstack/rally" title="Rally源码" target="_blank" rel="noopener"> Rally 源码</a>自己修改构建。接下来结合官方的 Dockerfile 文件，自定义修改属于我们自己的 Rally 镜像。</p><h6 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定一个基础镜像进行构建。命令参数 <code>FROM &lt;image&gt;:&lt;tag&gt;</code> ，这里使用 ubuntu:16.04 作为 Rally 的基础镜像，它将作为镜像第一层完成后续步骤构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　指定作者信息。命令参数 <code>MAINTAINER &lt;name&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Rally 所需依赖包及创建相应目录。Dockerfile 使用 <code>RUN &lt;command&gt;</code> 调用系统 shell 运行相关命令，多个命令不建议分别写多个 <code>RUN</code> 指令，因为这会使镜像层次变得复杂，而是建议使用 <code>&amp;&amp;</code> 和 <code>\</code> 连接多条命令并换行书写，优化构建的逻辑结构和代码的可读性。通过下述 5 个步骤完成前期准备，其中 source 是我用来存放下载源码的目录。</p><ul><li>更新软件列表</li><li>安装依赖软件</li><li>时区改为 CST</li><li>反注释开启命令参数补齐</li><li>创建 Rally 源码下载目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils iputils-ping vim wget git-core tzdata \</span><br><span class="line">    python python-pip python-dev &amp;&amp; \</span><br><span class="line">    pip install --upgrade pip &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/rally/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载 Rally 的安装脚本并进行必要修改后进行安装，同时替换掉需要调用墙外的 js 框架文件变为我们可访问的目标地址。</p><ul><li>下载 12.0.0 的 Rally 安装文件到 <code>/home/rally/</code></li><li>替换安装版本为 12.0.0</li><li>修改 Rally 的 <code>database</code> 保存在 <code>/home/rally/data/</code></li><li>下载的源码保存在 <code>/home/rally/source/</code></li><li>安装时拷贝 Rally 命令补全文件及开启运行容器时输出相关 Info</li><li>安装 Rally</li><li>替换 googleapis 上的 <code>angular.min.js</code> 为 cloudflare 网站上面的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RUN wget -P /home/rally/ https://raw.githubusercontent.com/openstack/rally/0.12.0/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_GIT_BRANCH=.*/RALLY_GIT_BRANCH="0.12.0"/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/^RALLY_DATABASE_DIR=.*/RALLY_DATABASE_DIR=\/home\/rally\/data/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">'s/SOURCEDIR="\$ORIG_WD".*/SOURCEDIR="\$ORIG_WD"\/home\/rally\/source/'</span> /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'cp $SOURCEDIR/etc/motd /etc/motd'</span> &gt;&gt; /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ ! -z "$TERM" -a -r /etc/motd ] &amp;&amp; cat /etc/motd'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'source /usr/local/etc/bash_completion.d/rally.bash_completion'</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    bash /home/rally/install_rally.sh &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/report.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/task/trends.html &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"s/ajax.googleapis.com\/ajax\/libs\/angularjs/cdnjs.cloudflare.com\/ajax\/libs\/angular.js/"</span> \</span><br><span class="line">           /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/rally/ui/templates/verification/report.html</span><br></pre></td></tr></table></figure><h6 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　拷贝 <code>build</code> 过程中指定的上下文目录文件到镜像内部。命令参数 <code>COPY &lt;src&gt;... &lt;dest&gt;</code> ，可以通过同目录下的 <code>.dockerignore</code> 忽略部分不需要传输的文件。这里我是将 Rally 自动测试的执行脚本拷贝到镜像内部，方便后续测试。</p><p>　　还有另外一个命令 <code>ADD</code> 可以理解为增强版的 <code>COPY</code> ，它不仅能将本地目录的文件拷贝到镜像中，同时还能降远程 url 的文件或目录拷贝至镜像里面，如果源文件是一个压缩包，在拷贝过程中还会自动解压。它的命令参数与 <code>COPY</code> 无二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY . /home/rally/</span><br></pre></td></tr></table></figure><h6 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　安装完毕后清理 apt 以及 pip 安装过程中的缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">    rm -rf /root/.cache/</span><br></pre></td></tr></table></figure><h6 id="Step-7"><a href="#Step-7" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　建立存放数据库的 <code>/home/rally/data/</code> 目录并重新创建 Rally 的数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /home/rally/data &amp;&amp; \</span><br><span class="line">    rally db recreate</span><br></pre></td></tr></table></figure><h6 id="Step-8"><a href="#Step-8" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　更改镜像工作目录，使得启动镜像后在 <code>/home/rally/</code> 目录执行命令等。命令参数 <code>WORKDIR &lt;dir&gt;</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /home/rally</span><br></pre></td></tr></table></figure><h6 id="Step-9"><a href="#Step-9" class="headerlink" title="Step 9"></a>Step 9</h6><p>　　为了令测试数据持久化，将镜像数据存储文件夹挂载到宿主机，命令参数 <code>VLOUME [&quot;&lt;dir&gt;&quot;]</code> 。启动容器的时候会在 <code>/var/lib/docker/volumes/</code> 下创建一个随机命名的文件夹并将其挂载关联，也可在启动时通过 <code>-v</code> 挂载到指定目录，便于数据的查看及持久化保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/home/rally"</span>]</span><br></pre></td></tr></table></figure><h6 id="Step-10"><a href="#Step-10" class="headerlink" title="Step 10"></a>Step 10</h6><p>　　官方是以 <code>ENTRYPOINT [&quot;rally&quot;]</code> 作为容器启动时的默认命令。我们启动容器时指定的命令都将作为参数传给 <code>rally</code> 调用，不会被重写覆盖，这也导致我们无法直接进入容器内部去执行其他操作，解决办法是在使用 <code>docker run</code> 的时候用 <code>--rm --entrypoint /bin/bash</code> 临时替换。测试过程中我喜欢进去容器内部操作，因此摒弃 <code>ENTRYPOINT</code> 而用 <code>CMD</code> 命令，它允许我们启动时用别的命令覆盖，进行其他操作。两者的命令参数为 <code>ENTRYPOINT/CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 。一个Dockerfile文件仅允许一个<code>ENTRYPOINT</code> 和 <code>CMD</code> 存在，多次存在的话只有最后一次会生效。当两者同时存在的情况下，可以使用 <code>CMD</code> 给 <code>ENTRYPOINT</code> 传参，比如 <code>ENTRYPOINT [&quot;rally&quot;]</code> <code>CMD [&quot;--version&quot;]</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此一个 Rally 的 Dockerfile 文件编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Rally 容器镜像。构建完毕后可通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t rally_container:0.12.0 .</span><br></pre></td></tr></table></figure><h6 id="附录：Rally-Documentation"><a href="#附录：Rally-Documentation" class="headerlink" title="附录：Rally Documentation "></a><font color="#FF0000">附录：Rally Documentation </font></h6><div class="row">    <embed src="https://media.readthedocs.org/pdf/rally/stable/rally.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Tempest"><a href="#Tempest" class="headerlink" title="Tempest"></a>Tempest</h3><blockquote><p>　　Tempest 是 Openstack 的集成测试框架，对于验证 OpenStack 部署，包含了基本组件的 API 测试、场景测试和单元测试。Tempest 对 Openstack 终端发起一系列 API 请求，并且对终端的响应进行验证。它可以验证代码的正确性，使得 OpenStack 相关测试效率得到大幅度提升，已经成为 OpenStack 项目中不可或缺的组成部分。</p></blockquote><div align="center" style="align:center"><br><font size="6">Tempest 代码架构 <br></font><br><img src="https://www.ibm.com/developerworks/cn/cloud/library/1403_liuyu_openstacktempest/image005.jpg" alt="Tempest 代码架构" title="Tempest 代码架构"><br><br></div><p>　　Tempest 没有官方的 Docker 镜像提供给我们参考和使用，我们可以按照自己安装过程中的步骤配置 Dockerfile 文件。此处仅记录我安装习惯的配置。</p><h6 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h6><p>　　指定 ubuntu:16.04 作为基础镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br></pre></td></tr></table></figure><h6 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h6><p>　　备注作者信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER AnanasYuu &lt;yuyihuang0702@163.com&gt;</span><br></pre></td></tr></table></figure><h6 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h6><p>　　安装 Tempest 依赖软件包、修改时区、反注释命令补全功能，创建源码下载目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install --yes \</span><br><span class="line">    bash-completion apt-utils vim git wget curl gcc tzdata \</span><br><span class="line">    python-dev python-libxml2 python-setuptools \</span><br><span class="line">    libxml2-dev libxslt-dev lib32z1-dev libssl-dev libxslt1-dev libsasl2-dev libsqlite3-dev libldap2-dev libffi-dev &amp;&amp; \</span><br><span class="line">    easy_install pip &amp;&amp; \</span><br><span class="line">    pip install --upgrade setuptools &amp;&amp; \</span><br><span class="line">    pip install xunit2testrail junitxml virtualenv python-openstackclient &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"export TZ='Asia/Shanghai'"</span> &gt;&gt; /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">"32,38s/^#//g"</span> /etc/bash.bashrc &amp;&amp; \</span><br><span class="line">    mkdir -p /home/tempest/<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h6 id="Step-4-1"><a href="#Step-4-1" class="headerlink" title="Step 4"></a>Step 4</h6><p>　　下载版本为 18.0.0 的 Tempest 源码，<code>pip</code> 安装所需依赖组件及调试所需的 <code>ipdb</code> ，最后安装 Tempest。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    git <span class="built_in">clone</span> -b 18.0.0 https://git.openstack.org/openstack/tempest ./ &amp;&amp; \</span><br><span class="line">    pip install -r ./requirements.txt &amp;&amp; \</span><br><span class="line">    pip install -r ./<span class="built_in">test</span>-requirements.txt &amp;&amp; \</span><br><span class="line">    pip install nose tox ipdb &amp;&amp; \</span><br><span class="line">    pip install .</span><br></pre></td></tr></table></figure><h6 id="Step-5-1"><a href="#Step-5-1" class="headerlink" title="Step 5"></a>Step 5</h6><p>　　生成配置文件样本并拷贝一份以便后续配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /home/tempest/<span class="built_in">source</span> &amp;&amp; \</span><br><span class="line">    tox -egenconfig &amp;&amp; \</span><br><span class="line">    cp etc/accounts.yaml.sample etc/accounts.yaml &amp;&amp; \</span><br><span class="line">    cp etc/tempest.conf.sample etc/tempest.conf</span><br></pre></td></tr></table></figure><h6 id="Step-6-1"><a href="#Step-6-1" class="headerlink" title="Step 6"></a>Step 6</h6><p>　　在 <code>/home/tempest/workdir</code> 文件夹中初始化 Tempest。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN tempest init /home/tempest/workdir</span><br></pre></td></tr></table></figure></p><h6 id="Step-7-1"><a href="#Step-7-1" class="headerlink" title="Step 7"></a>Step 7</h6><p>　　指定 Tempest 工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /root/tempest/workdir</span><br></pre></td></tr></table></figure><h6 id="Step-8-1"><a href="#Step-8-1" class="headerlink" title="Step 8"></a>Step 8</h6><p>　　指定容器启动命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>　　至此 Tempest 的 Dockerfile 文件也已编写完毕，将上面 Step 的代码结合，创建一个目录，并将代码文件命名为 Dockerfile 进行保存，执行下述命令即可构建属于我们的 Tempest 镜像。构建完毕后通过 <code>docker images</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t tempest_container:18.0.0 .</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>　　通过 Dockerfile 构建 Rally 以及 Tempest 镜像，不仅能让我们快速的搭建测试环境，也利于持续集成及持续交付过程中节省时间，统一及标准化环境。而且与 OpenStack 隔离开来，更是减少了测试过程中的互相干扰。并且 <code>Docker volume</code> 的存在也确保了测试输出结果能同步保存至宿主机并持久化。</p><p>　　最后将 Rally 以及 Tempest 的容器镜像上传至 <code>Docker Hub</code> 或者保存至本地 <code>registry</code> ，方便后续使用。</p><ul><li><a href="https://hub.docker.com/r/ananasyuu/docker_rally/" target="_blank" rel="noopener">Rally 镜像的 Docker Hub 链接</a></li><li><a href="https://hub.docker.com/r/ananasyuu/docker_tempest/" target="_blank" rel="noopener">Tempest 镜像的 Docker Hub 链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　&lt;code&gt;Rally&lt;/code&gt; 和 &lt;code&gt;Tempest&lt;/code&gt; 作为 OpenStack 的两个测试框架，在测试 OpenStack 这个庞然大物中扮演着不可或缺的角色。作为 OpenStack 的项目之一，在使用过程中势必会调用部分 OpenStack 的运行库，这将有可能对整个环境造成污染，也不利于多云平台的复用及隔离。&lt;/p&gt;
&lt;p&gt;　　Docker 的出现，无疑为我们提供了完美的解决方法。通过容器化将 Rally 以及 Tempest 制作成基础镜像，并与宿主机 OS 隔离，不仅可以减少主机资源占用而且也便于管理维护及平台间的移植。总的来说，使用 Dockerfile 构建 Rally 和 Tempest，有着下面几个优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 隔离主机资源：隔断容器与宿主机之间的文件交互，避免交叉感染； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 轻量及统一化：容器比起虚拟机更加小巧，同时通过 Dockerfile 构建模板镜像可以使测试环境做到标准、统一化； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 易扩展可复用：将构建需求分成多步 &lt;font color=&quot;#FF0000&quot;&gt; Step &lt;/font&gt; 写入文件中，使得以后的修改和扩展以及版本控制都变得极为便捷，而 Docker 的 &lt;font color=&quot;#FF0000&quot;&gt; Libcontainer &lt;/font&gt; 引擎也令跨平台复用变得易如反掌； &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008844&quot;&gt; 便捷性高效性：一次构建后，之后便可以使用该镜像快速分发，达到开箱即用的程度，而后续资源的管理和回收等都变得相当轻松可控。&lt;/font&gt;

&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.ananasyu.top/categories/Docker/"/>
    
    
      <category term="Dockerfile" scheme="https://www.ananasyu.top/tags/Dockerfile/"/>
    
      <category term="Rally" scheme="https://www.ananasyu.top/tags/Rally/"/>
    
      <category term="Tempest" scheme="https://www.ananasyu.top/tags/Tempest/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Hexo !</title>
    <link href="https://www.ananasyu.top/posts/Hello-Hexo.html"/>
    <id>https://www.ananasyu.top/posts/Hello-Hexo.html</id>
    <published>2018-05-10T09:50:30.000Z</published>
    <updated>2018-05-21T10:39:50.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo1.jpg" alt=""><br></div><a id="more"></a><p>　</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>　　回想起高二高三那时折腾塞班系统的固件，为 <font color="#66CDAA">Nokia N79</font> 美化及优化原生系统；从高三暑假才拥有属于自己的电脑的小白到大学当网管头头带领十几个人穿梭在男男女女的学生宿舍之中，解决 Ta 们使用校园网遇到的各种问题（然而也没有找到另一半Ｔ▽Ｔ）；再到现如今藏匿在<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%B9%BF%E5%B7%9E%E7%A0%94%E7%A9%B6%E9%99%A2/92623" title="中国电信广州研究院" target="_blank" rel="noopener">中国电信广州研究院</a>从事着虚拟化及云计算测试相关。发现自己的涉猎面越来越广，无论技术还是兴趣~~~</p><p>　　没事哼哼小曲儿，凭着自己头脑里的想法去尝试改进工作中的流程，能将工作融入到生活中是我希望达到的状态。作为一个测试人员需要学习的知识还是很多，产品熟悉度及工具的创新及运用也不是件容易事。希望接下来的博客能较多的涉猎以下内容，鞭策自己向着更深更好的方向前进。</p><ul><li><div><img style="margin:0px 6px 7px 0px" src="https://wiki.openstack.org/favicon.ico" width="27" height="27"> <a href="https://www.openstack.org/" target="_blank" rel="noopener"><font size="5">OpenStack</font></a></div></li><li><div><img style="margin:0px 1px 12px -5px" src="https://www.docker.com/favicon.ico" width="36" height="36"> <a href="https://www.docker.com/" target="_blank" rel="noopener"><font size="5">Docker</font></a></div></li><li><div><img style="margin:0px 10px 10px 0px" src="https://jenkins.io/sites/default/files/jenkins_favicon.ico" width="27" height="27"> <a href="https://jenkins.io/" target="_blank" rel="noopener"><font size="5">Jenkins</font></a></div></li><li><div><img style="margin:0px 5px 6px 0px" src="https://www.python.org/static/favicon.ico" width="27" height="27"> <a href="https://www.python.org/" target="_blank" rel="noopener"><font size="5">Python</font></a><br><br></div></li></ul><p>　　趁着现在热情正盛，工作中的 idea 和技术实现还没有忘记的时候及时记录下来，弥补日常工作总结中的不足。就怕前期高产，等到脑中的想法被挖空得差不多了之后就写不出东西了，走走看看呗。接下来的日子里，立个目标——每周一篇以上的文章。等到以后过上了佛系养生亦或者工作忙碌的无暇更新的时候，再回头看看自己曾经写下的经历、不足以及成长！！！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>　　折腾了几天下来，博客的雏形就暂时定这样子吧。使用 <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 搭建博客还是挺简单的。当看到这个博客展现在眼前的时候，心情确实有点激动，也特别感谢 <a href="http://litten.me" title="Litten的博客" target="_blank" rel="noopener">Litten</a> 制作的主题 <a href="https://github.com/litten/hexo-theme-yilia" title="Yilia主题" target="_blank" rel="noopener">Yilia</a>，非常喜欢这种简洁的双栏主题，交互方便又美观大方。说实在的，第一次尝试用 <a href="http://wowubuntu.com/markdown/index.html" title="Markdown语法中文完整版" target="_blank" rel="noopener">Markdown</a> 语法写文章，而且好久没执笔写过东西了，以后再慢慢改进排版吧！</p><div align="center"><br><img src="https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo2.jpg" alt=""><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　工作时间一长，慢慢的发现自己的脑子不好使了，接触的东西越来越多，忘的也越来越多。深思熟虑之后，希望以此博客，记录下自己生活中所见所闻以及将职业生涯中的技术理解保存下来，以便日后温习回顾。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PaulYuuu/BligPicture/master/img/Hello-Hexo/2018-05-11_HelloHexo1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="essay" scheme="https://www.ananasyu.top/tags/essay/"/>
    
  </entry>
  
</feed>
